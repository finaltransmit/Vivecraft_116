--- a/net/optifine/shaders/Shaders.java
+++ b/net/optifine/shaders/Shaders.java
@@ -2,6 +2,7 @@
 
 import com.mojang.blaze3d.matrix.MatrixStack;
 import com.mojang.blaze3d.platform.GlStateManager;
+import java.awt.Dimension;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
@@ -11,7 +12,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.io.Reader;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
@@ -50,6 +50,7 @@
 import net.minecraft.client.resources.I18n;
 import net.minecraft.client.resources.data.TextureMetadataSection;
 import net.minecraft.client.settings.CloudOption;
+import net.minecraft.client.settings.PointOfView;
 import net.minecraft.client.shader.FramebufferConstants;
 import net.minecraft.client.world.ClientWorld;
 import net.minecraft.entity.Entity;
@@ -65,8 +66,10 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.vector.Matrix4f;
+import net.minecraft.util.math.vector.Vector2f;
 import net.minecraft.util.math.vector.Vector3d;
 import net.minecraft.util.math.vector.Vector3f;
+import net.minecraft.util.math.vector.Vector3i;
 import net.minecraft.util.math.vector.Vector4f;
 import net.minecraft.util.registry.Registry;
 import net.minecraft.util.text.StringTextComponent;
@@ -111,7 +114,10 @@
 import net.optifine.texture.PixelFormat;
 import net.optifine.texture.PixelType;
 import net.optifine.texture.TextureType;
+import net.optifine.util.ArrayUtils;
+import net.optifine.util.DynamicDimension;
 import net.optifine.util.EntityUtils;
+import net.optifine.util.LineBuffer;
 import net.optifine.util.PropertiesOrdered;
 import net.optifine.util.StrUtils;
 import net.optifine.util.TimedEvent;
@@ -123,10 +129,13 @@
 import org.lwjgl.opengl.ARBShaderObjects;
 import org.lwjgl.opengl.ARBVertexShader;
 import org.lwjgl.opengl.EXTFramebufferObject;
+import org.lwjgl.opengl.EXTGeometryShader4;
 import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL11;
-import org.lwjgl.opengl.GL32;
+import org.lwjgl.opengl.GL43;
 import org.lwjgl.opengl.GLCapabilities;
+import org.lwjgl.opengl.KHRDebug;
+import org.vivecraft.render.RenderPass;
 
 public class Shaders
 {
@@ -168,9 +177,7 @@
     static float[] sunPosModelView = new float[] {0.0F, 100.0F, 0.0F, 0.0F};
     static float[] moonPosModelView = new float[] {0.0F, -100.0F, 0.0F, 0.0F};
     private static float[] tempMat = new float[16];
-    static float clearColorR;
-    static float clearColorG;
-    static float clearColorB;
+    static Vector4f clearColor = new Vector4f();
     static float skyColorR;
     static float skyColorG;
     static float skyColorB;
@@ -188,6 +195,8 @@
     static float frameTime = 0.0F;
     static float frameTimeCounter = 0.0F;
     static int systemTimeInt32 = 0;
+    public static PointOfView pointOfView = PointOfView.FIRST_PERSON;
+    public static boolean pointOfViewChanged = false;
     static float rainStrength = 0.0F;
     static float wetness = 0.0F;
     public static float wetnessHalfLife = 600.0F;
@@ -208,17 +217,25 @@
     static float blindness = 0.0F;
     static boolean lightmapEnabled = false;
     static boolean fogEnabled = true;
+    static RenderStage renderStage = RenderStage.NONE;
     private static int baseAttribId = 11;
     public static int entityAttrib = baseAttribId + 0;
     public static int midTexCoordAttrib = baseAttribId + 1;
     public static int tangentAttrib = baseAttribId + 2;
+    public static int velocityAttrib = baseAttribId + 3;
+    public static int midBlockAttrib = baseAttribId + 4;
     public static boolean useEntityAttrib = false;
     public static boolean useMidTexCoordAttrib = false;
     public static boolean useTangentAttrib = false;
+    public static boolean useVelocityAttrib = false;
+    public static boolean useMidBlockAttrib = false;
     public static boolean progUseEntityAttrib = false;
     public static boolean progUseMidTexCoordAttrib = false;
     public static boolean progUseTangentAttrib = false;
+    public static boolean progUseVelocityAttrib = false;
+    public static boolean progUseMidBlockAttrib = false;
     private static boolean progArbGeometryShader4 = false;
+    private static boolean progExtGeometryShader4 = false;
     private static int progMaxVerticesOut = 3;
     private static boolean hasGeometryShaders = false;
     public static int atlasSizeX = 0;
@@ -259,6 +276,22 @@
     public static ShaderUniform1i uniform_colortex7 = shaderUniforms.make1i("colortex7");
     public static ShaderUniform1i uniform_gdepthtex = shaderUniforms.make1i("gdepthtex");
     public static ShaderUniform1i uniform_depthtex2 = shaderUniforms.make1i("depthtex2");
+    public static ShaderUniform1i uniform_colortex8 = shaderUniforms.make1i("colortex8");
+    public static ShaderUniform1i uniform_colortex9 = shaderUniforms.make1i("colortex9");
+    public static ShaderUniform1i uniform_colortex10 = shaderUniforms.make1i("colortex10");
+    public static ShaderUniform1i uniform_colortex11 = shaderUniforms.make1i("colortex11");
+    public static ShaderUniform1i uniform_colortex12 = shaderUniforms.make1i("colortex12");
+    public static ShaderUniform1i uniform_colortex13 = shaderUniforms.make1i("colortex13");
+    public static ShaderUniform1i uniform_colortex14 = shaderUniforms.make1i("colortex14");
+    public static ShaderUniform1i uniform_colortex15 = shaderUniforms.make1i("colortex15");
+    public static ShaderUniform1i uniform_colorimg0 = shaderUniforms.make1i("colorimg0");
+    public static ShaderUniform1i uniform_colorimg1 = shaderUniforms.make1i("colorimg1");
+    public static ShaderUniform1i uniform_colorimg2 = shaderUniforms.make1i("colorimg2");
+    public static ShaderUniform1i uniform_colorimg3 = shaderUniforms.make1i("colorimg3");
+    public static ShaderUniform1i uniform_colorimg4 = shaderUniforms.make1i("colorimg4");
+    public static ShaderUniform1i uniform_colorimg5 = shaderUniforms.make1i("colorimg5");
+    public static ShaderUniform1i uniform_shadowcolorimg0 = shaderUniforms.make1i("shadowcolorimg0");
+    public static ShaderUniform1i uniform_shadowcolorimg1 = shaderUniforms.make1i("shadowcolorimg1");
     public static ShaderUniform1i uniform_tex = shaderUniforms.make1i("tex");
     public static ShaderUniform1i uniform_heldItemId = shaderUniforms.make1i("heldItemId");
     public static ShaderUniform1i uniform_heldBlockLightValue = shaderUniforms.make1i("heldBlockLightValue");
@@ -311,9 +344,11 @@
     public static ShaderUniform1i uniform_hideGUI = shaderUniforms.make1i("hideGUI");
     public static ShaderUniform1f uniform_centerDepthSmooth = shaderUniforms.make1f("centerDepthSmooth");
     public static ShaderUniform2i uniform_atlasSize = shaderUniforms.make2i("atlasSize");
+    public static ShaderUniform4f uniform_spriteBounds = shaderUniforms.make4f("spriteBounds");
     public static ShaderUniform4i uniform_blendFunc = shaderUniforms.make4i("blendFunc");
     public static ShaderUniform1i uniform_instanceId = shaderUniforms.make1i("instanceId");
     public static ShaderUniform1f uniform_playerMood = shaderUniforms.make1f("playerMood");
+    public static ShaderUniform1i uniform_renderStage = shaderUniforms.make1i("renderStage");
     static double previousCameraPositionX;
     static double previousCameraPositionY;
     static double previousCameraPositionZ;
@@ -322,7 +357,7 @@
     static double cameraPositionZ;
     static int cameraOffsetX;
     static int cameraOffsetZ;
-    static int shadowPassInterval = 0;
+    static boolean hasShadowMap = false;
     public static boolean needResizeShadow = false;
     static int shadowMapWidth = 1024;
     static int shadowMapHeight = 1024;
@@ -332,30 +367,37 @@
     static float shadowMapHalfPlane = 160.0F;
     static boolean shadowMapIsOrtho = true;
     static float shadowDistanceRenderMul = -1.0F;
-    static int shadowPassCounter = 0;
     public static boolean shouldSkipDefaultShadow = false;
     static boolean waterShadowEnabled = false;
-    static final int MaxDrawBuffers = 8;
-    static final int MaxColorBuffers = 8;
-    static final int MaxDepthBuffers = 3;
-    static final int MaxShadowColorBuffers = 8;
-    static final int MaxShadowDepthBuffers = 2;
+    public static final int MaxDrawBuffers = 8;
+    public static final int MaxColorBuffers = 16;
+    public static final int MaxDepthBuffers = 3;
+    public static final int MaxShadowColorBuffers = 2;
+    public static final int MaxShadowDepthBuffers = 2;
     static int usedColorBuffers = 0;
-    static int usedDepthBuffers = 0;
+    public static int usedDepthBuffers = 0;
     static int usedShadowColorBuffers = 0;
     static int usedShadowDepthBuffers = 0;
     static int usedColorAttachs = 0;
     static int usedDrawBuffers = 0;
-    static int dfb = 0;
-    static int sfb = 0;
-    private static int[] gbuffersFormat = new int[8];
-    public static boolean[] gbuffersClear = new boolean[8];
-    public static Vector4f[] gbuffersClearColor = new Vector4f[8];
+    static boolean bindImageTextures = false;
+    public static ShadersFramebuffer dfb;
+    static ShadersFramebuffer sfb;
+    private static int[] gbuffersFormat = new int[16];
+    public static boolean[] gbuffersClear = new boolean[16];
+    public static Vector4f[] gbuffersClearColor = new Vector4f[16];
+    private static final Vector4f CLEAR_COLOR_0 = new Vector4f(0.0F, 0.0F, 0.0F, 0.0F);
+    private static final Vector4f CLEAR_COLOR_1 = new Vector4f(1.0F, 1.0F, 1.0F, 1.0F);
+    private static int[] shadowBuffersFormat = new int[2];
+    public static boolean[] shadowBuffersClear = new boolean[2];
+    public static Vector4f[] shadowBuffersClearColor = new Vector4f[2];
     private static Programs programs = new Programs();
     public static final Program ProgramNone = programs.getProgramNone();
     public static final Program ProgramShadow = programs.makeShadow("shadow", ProgramNone);
     public static final Program ProgramShadowSolid = programs.makeShadow("shadow_solid", ProgramShadow);
     public static final Program ProgramShadowCutout = programs.makeShadow("shadow_cutout", ProgramShadow);
+    public static final Program[] ProgramsShadowcomp = programs.makeShadowcomps("shadowcomp", 16);
+    public static final Program[] ProgramsPrepare = programs.makePrepares("prepare", 16);
     public static final Program ProgramBasic = programs.makeGbuffers("gbuffers_basic", ProgramNone);
     public static final Program ProgramTextured = programs.makeGbuffers("gbuffers_textured", ProgramBasic);
     public static final Program ProgramTexturedLit = programs.makeGbuffers("gbuffers_textured_lit", ProgramTextured);
@@ -391,16 +433,16 @@
     public static int activeProgramID = 0;
     private static ProgramStack programStack = new ProgramStack();
     private static boolean hasDeferredPrograms = false;
-    static IntBuffer activeDrawBuffers = null;
-    private static int activeCompositeMipmapSetting = 0;
+    public static boolean hasShadowcompPrograms = false;
+    public static boolean hasPreparePrograms = false;
     public static Properties loadedShaders = null;
     public static Properties shadersConfig = null;
     public static Texture defaultTexture = null;
     public static boolean[] shadowHardwareFilteringEnabled = new boolean[2];
     public static boolean[] shadowMipmapEnabled = new boolean[2];
     public static boolean[] shadowFilterNearest = new boolean[2];
-    public static boolean[] shadowColorMipmapEnabled = new boolean[8];
-    public static boolean[] shadowColorFilterNearest = new boolean[8];
+    public static boolean[] shadowColorMipmapEnabled = new boolean[2];
+    public static boolean[] shadowColorFilterNearest = new boolean[2];
     public static boolean configTweakBlockDamage = false;
     public static boolean configCloudShadow = false;
     public static float configHandDepthMul = 0.125F;
@@ -443,7 +485,10 @@
     public static PropertyDefaultTrueFalse shaderPackOldLighting = new PropertyDefaultTrueFalse("oldLighting", "Classic Lighting", 0);
     public static PropertyDefaultTrueFalse shaderPackOldHandLight = new PropertyDefaultTrueFalse("oldHandLight", "Old Hand Light", 0);
     public static PropertyDefaultTrueFalse shaderPackDynamicHandLight = new PropertyDefaultTrueFalse("dynamicHandLight", "Dynamic Hand Light", 0);
+    public static PropertyDefaultTrueFalse shaderPackShadowTerrain = new PropertyDefaultTrueFalse("shadowTerrain", "Shadow Terrain", 0);
     public static PropertyDefaultTrueFalse shaderPackShadowTranslucent = new PropertyDefaultTrueFalse("shadowTranslucent", "Shadow Translucent", 0);
+    public static PropertyDefaultTrueFalse shaderPackShadowEntities = new PropertyDefaultTrueFalse("shadowEntities", "Shadow Entities", 0);
+    public static PropertyDefaultTrueFalse shaderPackShadowBlockEntities = new PropertyDefaultTrueFalse("shadowBlockEntities", "Shadow Block Entities", 0);
     public static PropertyDefaultTrueFalse shaderPackUnderwaterOverlay = new PropertyDefaultTrueFalse("underwaterOverlay", "Underwater Overlay", 0);
     public static PropertyDefaultTrueFalse shaderPackSun = new PropertyDefaultTrueFalse("sun", "Sun", 0);
     public static PropertyDefaultTrueFalse shaderPackMoon = new PropertyDefaultTrueFalse("moon", "Moon", 0);
@@ -462,14 +507,11 @@
     private static ICustomTexture[] customTexturesGbuffers = null;
     private static ICustomTexture[] customTexturesComposite = null;
     private static ICustomTexture[] customTexturesDeferred = null;
+    private static ICustomTexture[] customTexturesShadowcomp = null;
+    private static ICustomTexture[] customTexturesPrepare = null;
     private static String noiseTexturePath = null;
+    private static DynamicDimension[] colorBufferSizes = new DynamicDimension[16];
     private static CustomUniforms customUniforms = null;
-    private static final int STAGE_GBUFFERS = 0;
-    private static final int STAGE_COMPOSITE = 1;
-    private static final int STAGE_DEFERRED = 2;
-    private static final String[] STAGE_NAMES = new String[] {"gbuffers", "composite", "deferred"};
-    public static final boolean enableShadersOption = true;
-    private static final boolean enableShadersDebug = true;
     public static final boolean saveFinalShaders = System.getProperty("shaders.debug.save", "false").equals("true");
     public static float blockLightLevel05 = 0.5F;
     public static float blockLightLevel06 = 0.6F;
@@ -488,8 +530,13 @@
     private static ICustomTexture noiseTexture;
     private static boolean noiseTextureEnabled = false;
     private static int noiseTextureResolution = 256;
-    static final int[] colorTextureImageUnit = new int[] {0, 1, 2, 3, 7, 8, 9, 10};
-    private static final int bigBufferSize = (285 + 8 * ProgramCount) * 4;
+    static final int[] colorTextureImageUnit = new int[] {0, 1, 2, 3, 7, 8, 9, 10, 16, 17, 18, 19, 20, 21, 22, 23};
+    static final int[] depthTextureImageUnit = new int[] {6, 11, 12};
+    static final int[] shadowColorTextureImageUnit = new int[] {13, 14};
+    static final int[] shadowDepthTextureImageUnit = new int[] {4, 5};
+    static final int[] colorImageUnit = new int[] {0, 1, 2, 3, 4, 5};
+    static final int[] shadowColorImageUnit = new int[] {6, 7};
+    private static final int bigBufferSize = (295 + 8 * ProgramCount) * 4;
     private static final ByteBuffer bigBuffer = (ByteBuffer)((Buffer)BufferUtils.createByteBuffer(bigBufferSize)).limit(0);
     static final float[] faProjection = new float[16];
     static final float[] faProjectionInverse = new float[16];
@@ -511,18 +558,15 @@
     static final FloatBuffer previousModelView = nextFloatBuffer(16);
     static final FloatBuffer tempMatrixDirectBuffer = nextFloatBuffer(16);
     static final FloatBuffer tempDirectFloatBuffer = nextFloatBuffer(16);
-    static final IntBuffer dfbColorTextures = nextIntBuffer(16);
-    static final IntBuffer dfbDepthTextures = nextIntBuffer(3);
-    static final IntBuffer sfbColorTextures = nextIntBuffer(8);
-    static final IntBuffer sfbDepthTextures = nextIntBuffer(2);
-    static final IntBuffer dfbDrawBuffers = nextIntBuffer(8);
-    static final IntBuffer sfbDrawBuffers = nextIntBuffer(8);
-    static final IntBuffer drawBuffersNone = (IntBuffer)((Buffer)nextIntBuffer(8)).limit(0);
-    static final IntBuffer drawBuffersColorAtt0 = (IntBuffer)((Buffer)nextIntBuffer(8).put(36064)).position(0).limit(1);
-    static final FlipTextures dfbColorTexturesFlip = new FlipTextures(dfbColorTextures, 8);
+    static final DrawBuffers dfbDrawBuffers = new DrawBuffers("dfbDrawBuffers", 16, 8);
+    static final DrawBuffers sfbDrawBuffers = new DrawBuffers("sfbDrawBuffers", 16, 8);
+    static final DrawBuffers drawBuffersNone = (new DrawBuffers("drawBuffersNone", 16, 8)).limit(0);
+    static final DrawBuffers[] drawBuffersColorAtt = makeDrawBuffersColorSingle(16);
+    static boolean glDebugGroups;
+    static boolean glDebugGroupProgram;
     static Map<Block, Integer> mapBlockToEntityData;
-    private static final String[] formatNames = new String[] {"R8", "RG8", "RGB8", "RGBA8", "R8_SNORM", "RG8_SNORM", "RGB8_SNORM", "RGBA8_SNORM", "R16", "RG16", "RGB16", "RGBA16", "R16_SNORM", "RG16_SNORM", "RGB16_SNORM", "RGBA16_SNORM", "R16F", "RG16F", "RGB16F", "RGBA16F", "R32F", "RG32F", "RGB32F", "RGBA32F", "R32I", "RG32I", "RGB32I", "RGBA32I", "R32UI", "RG32UI", "RGB32UI", "RGBA32UI", "R3_G3_B2", "RGB5_A1", "RGB10_A2", "R11F_G11F_B10F", "RGB9_E5"};
-    private static final int[] formatIds = new int[] {33321, 33323, 32849, 32856, 36756, 36757, 36758, 36759, 33322, 33324, 32852, 32859, 36760, 36761, 36762, 36763, 33325, 33327, 34843, 34842, 33326, 33328, 34837, 34836, 33333, 33339, 36227, 36226, 33334, 33340, 36209, 36208, 10768, 32855, 32857, 35898, 35901};
+    private static final String[] formatNames = new String[] {"R8", "RG8", "RGB8", "RGBA8", "R8_SNORM", "RG8_SNORM", "RGB8_SNORM", "RGBA8_SNORM", "R8I", "RG8I", "RGB8I", "RGBA8I", "R8UI", "RG8UI", "RGB8UI", "RGBA8UI", "R16", "RG16", "RGB16", "RGBA16", "R16_SNORM", "RG16_SNORM", "RGB16_SNORM", "RGBA16_SNORM", "R16F", "RG16F", "RGB16F", "RGBA16F", "R16I", "RG16I", "RGB16I", "RGBA16I", "R16UI", "RG16UI", "RGB16UI", "RGBA16UI", "R32F", "RG32F", "RGB32F", "RGBA32F", "R32I", "RG32I", "RGB32I", "RGBA32I", "R32UI", "RG32UI", "RGB32UI", "RGBA32UI", "R3_G3_B2", "RGB5_A1", "RGB10_A2", "R11F_G11F_B10F", "RGB9_E5"};
+    private static final int[] formatIds = new int[] {33321, 33323, 32849, 32856, 36756, 36757, 36758, 36759, 33329, 33335, 36239, 36238, 33330, 33336, 36221, 36220, 33322, 33324, 32852, 32859, 36760, 36761, 36762, 36763, 33325, 33327, 34843, 34842, 33331, 33337, 36233, 36232, 33332, 33338, 36215, 36214, 33326, 33328, 34837, 34836, 33333, 33339, 36227, 36226, 33334, 33340, 36209, 36208, 10768, 32855, 32857, 35898, 35901};
     private static final Pattern patternLoadEntityDataMap = Pattern.compile("\\s*([\\w:]+)\\s*=\\s*([-]?\\d+)\\s*");
     public static int[] entityData = new int[32];
     public static int entityDataIndex = 0;
@@ -531,6 +575,11 @@
     {
     }
 
+    //Vivecraft
+    static float[] sunPositionT = new float[4];
+    static float[] moonPositionT = new float[4];
+    //
+    
     private static ByteBuffer nextByteBuffer(int size)
     {
         ByteBuffer bytebuffer = bigBuffer;
@@ -567,6 +616,22 @@
         return aintbuffer;
     }
 
+    private static DrawBuffers[] makeDrawBuffersColorSingle(int count)
+    {
+        DrawBuffers[] adrawbuffers = new DrawBuffers[count];
+
+        for (int i = 0; i < adrawbuffers.length; ++i)
+        {
+            DrawBuffers drawbuffers = new DrawBuffers("single" + i, 16, 8);
+            drawbuffers.put(36064 + i);
+            drawbuffers.position(0);
+            drawbuffers.limit(1);
+            adrawbuffers[i] = drawbuffers;
+        }
+
+        return adrawbuffers;
+    }
+
     public static void loadConfig()
     {
         SMCLog.info("Load shaders configuration.");
@@ -883,7 +948,29 @@
         loadShaderPackResources();
         loadShaderPackDimensions();
         shaderPackOptions = loadShaderPackOptions();
-        loadShaderPackProperties();
+
+        //Vivecraft clean shader options
+        for (ShaderOption sh : shaderPackOptions) {
+        	System.out.println("Shader Option: " + sh.toString());
+        	if (sh.getName().toLowerCase().contains("motion_blur")) //seus
+        		sh.setValue("false");
+        	if (sh.getName().toLowerCase().contains("motionblur")) //bsl, UShader
+        		sh.setValue("false");
+        	if (sh.getName().toLowerCase().contains("dof")) //bsl
+        		sh.setValue("false");
+        	if (sh.getName().toLowerCase().contains("dirtyLens")) //bsl
+        		sh.setValue("false");
+        	if (sh.getName().toLowerCase().contains("lensflare")) //bsl
+        		sh.setValue("false");
+        	if (sh.getName().toLowerCase().contains("idle_hands")) //qol
+        		sh.setValue("false");
+        	if (sh.getName().toLowerCase().contains("taa")) //sildurs
+        		sh.setValue("false");
+        }
+        //
+
+        loadShaderPackFixedProperties();
+        loadShaderPackDynamicProperties();
         boolean flag3 = shaderPackLoaded != flag;
         boolean flag4 = isOldLighting() != flag1;
 
@@ -987,13 +1074,50 @@
         }
     }
 
-    private static void loadShaderPackProperties()
+    private static void loadShaderPackFixedProperties()
+    {
+        shaderPackOldLighting.resetValue();
+        shaderPackSeparateAo.resetValue();
+
+        if (shaderPack != null)
+        {
+            String s = "/shaders/shaders.properties";
+
+            try
+            {
+                InputStream inputstream = shaderPack.getResourceAsStream(s);
+
+                if (inputstream == null)
+                {
+                    return;
+                }
+
+                inputstream = MacroProcessor.process(inputstream, s, false);
+                Properties properties = new PropertiesOrdered();
+                properties.load(inputstream);
+                inputstream.close();
+                shaderPackOldLighting.loadFrom(properties);
+                shaderPackSeparateAo.loadFrom(properties);
+                shaderPackOptionSliders = ShaderPackParser.parseOptionSliders(properties, shaderPackOptions);
+                shaderPackProfiles = ShaderPackParser.parseProfiles(properties, shaderPackOptions);
+                shaderPackGuiScreens = ShaderPackParser.parseGuiScreens(properties, shaderPackProfiles, shaderPackOptions);
+            }
+            catch (IOException ioexception)
+            {
+                Config.warn("[Shaders] Error reading: " + s);
+            }
+        }
+    }
+
+    private static void loadShaderPackDynamicProperties()
     {
         shaderPackClouds.resetValue();
         shaderPackOldHandLight.resetValue();
         shaderPackDynamicHandLight.resetValue();
-        shaderPackOldLighting.resetValue();
+        shaderPackShadowTerrain.resetValue();
         shaderPackShadowTranslucent.resetValue();
+        shaderPackShadowEntities.resetValue();
+        shaderPackShadowBlockEntities.resetValue();
         shaderPackUnderwaterOverlay.resetValue();
         shaderPackSun.resetValue();
         shaderPackMoon.resetValue();
@@ -1004,7 +1128,6 @@
         shaderPackBackFaceTranslucent.resetValue();
         shaderPackRainDepth.resetValue();
         shaderPackBeaconBeamDepth.resetValue();
-        shaderPackSeparateAo.resetValue();
         shaderPackFrustumCulling.resetValue();
         BlockAliases.reset();
         ItemAliases.reset();
@@ -1017,6 +1140,8 @@
             program.resetProperties();
         }
 
+        Arrays.fill(colorBufferSizes, (Object)null);
+
         if (shaderPack != null)
         {
             BlockAliases.update(shaderPack);
@@ -1033,15 +1158,17 @@
                     return;
                 }
 
-                inputstream = MacroProcessor.process(inputstream, s);
+                inputstream = MacroProcessor.process(inputstream, s, true);
                 Properties properties = new PropertiesOrdered();
                 properties.load(inputstream);
                 inputstream.close();
                 shaderPackClouds.loadFrom(properties);
                 shaderPackOldHandLight.loadFrom(properties);
                 shaderPackDynamicHandLight.loadFrom(properties);
-                shaderPackOldLighting.loadFrom(properties);
+                shaderPackShadowTerrain.loadFrom(properties);
                 shaderPackShadowTranslucent.loadFrom(properties);
+                shaderPackShadowEntities.loadFrom(properties);
+                shaderPackShadowBlockEntities.loadFrom(properties);
                 shaderPackUnderwaterOverlay.loadFrom(properties);
                 shaderPackSun.loadFrom(properties);
                 shaderPackVignette.loadFrom(properties);
@@ -1052,15 +1179,13 @@
                 shaderPackBackFaceTranslucent.loadFrom(properties);
                 shaderPackRainDepth.loadFrom(properties);
                 shaderPackBeaconBeamDepth.loadFrom(properties);
-                shaderPackSeparateAo.loadFrom(properties);
                 shaderPackFrustumCulling.loadFrom(properties);
-                shaderPackOptionSliders = ShaderPackParser.parseOptionSliders(properties, shaderPackOptions);
-                shaderPackProfiles = ShaderPackParser.parseProfiles(properties, shaderPackOptions);
-                shaderPackGuiScreens = ShaderPackParser.parseGuiScreens(properties, shaderPackProfiles, shaderPackOptions);
                 shaderPackProgramConditions = ShaderPackParser.parseProgramConditions(properties, shaderPackOptions);
-                customTexturesGbuffers = loadCustomTextures(properties, 0);
-                customTexturesComposite = loadCustomTextures(properties, 1);
-                customTexturesDeferred = loadCustomTextures(properties, 2);
+                customTexturesGbuffers = loadCustomTextures(properties, ProgramStage.GBUFFERS);
+                customTexturesComposite = loadCustomTextures(properties, ProgramStage.COMPOSITE);
+                customTexturesDeferred = loadCustomTextures(properties, ProgramStage.DEFERRED);
+                customTexturesShadowcomp = loadCustomTextures(properties, ProgramStage.SHADOWCOMP);
+                customTexturesPrepare = loadCustomTextures(properties, ProgramStage.PREPARE);
                 noiseTexturePath = properties.getProperty("texture.noise");
 
                 if (noiseTexturePath != null)
@@ -1073,6 +1198,7 @@
                 ShaderPackParser.parseBlendStates(properties);
                 ShaderPackParser.parseRenderScales(properties);
                 ShaderPackParser.parseBuffersFlip(properties);
+                colorBufferSizes = ShaderPackParser.parseBufferSizes(properties, 16);
             }
             catch (IOException ioexception)
             {
@@ -1081,9 +1207,9 @@
         }
     }
 
-    private static ICustomTexture[] loadCustomTextures(Properties props, int stage)
+    private static ICustomTexture[] loadCustomTextures(Properties props, ProgramStage stage)
     {
-        String s = "texture." + STAGE_NAMES[stage] + ".";
+        String s = "texture." + stage.getName() + ".";
         Set set = props.keySet();
         List<ICustomTexture> list = new ArrayList<>();
 
@@ -1175,6 +1301,23 @@
         return new CustomTextureLocation(textureUnit, resourcelocation, i);
     }
 
+    private static void reloadCustomTexturesLocation(ICustomTexture[] cts)
+    {
+        if (cts != null)
+        {
+            for (int i = 0; i < cts.length; ++i)
+            {
+                ICustomTexture icustomtexture = cts[i];
+
+                if (icustomtexture instanceof CustomTextureLocation)
+                {
+                    CustomTextureLocation customtexturelocation = (CustomTextureLocation)icustomtexture;
+                    customtexturelocation.reloadTexture();
+                }
+            }
+        }
+    }
+
     private static ICustomTexture loadCustomTextureRaw(int textureUnit, String line)
     {
         ConnectedParser connectedparser = new ConnectedParser("Shaders");
@@ -1334,10 +1477,17 @@
         }
     }
 
-    private static int getTextureIndex(int stage, String name)
+    private static int getTextureIndex(ProgramStage stage, String name)
     {
-        if (stage == 0)
+        if (stage == ProgramStage.GBUFFERS)
         {
+            int i = ShaderParser.getIndex(name, "colortex", 4, 15);
+
+            if (i >= 0)
+            {
+                return colorTextureImageUnit[i];
+            }
+
             if (name.equals("texture"))
             {
                 return 0;
@@ -1419,24 +1569,31 @@
             }
         }
 
-        if (stage == 1 || stage == 2)
+        if (stage.isAnyComposite())
         {
-            if (name.equals("colortex0") || name.equals("colortex0"))
+            int j = ShaderParser.getIndex(name, "colortex", 0, 15);
+
+            if (j >= 0)
+            {
+                return colorTextureImageUnit[j];
+            }
+
+            if (name.equals("colortex0"))
             {
                 return 0;
             }
 
-            if (name.equals("colortex1") || name.equals("gdepth"))
+            if (name.equals("gdepth"))
             {
                 return 1;
             }
 
-            if (name.equals("colortex2") || name.equals("gnormal"))
+            if (name.equals("gnormal"))
             {
                 return 2;
             }
 
-            if (name.equals("colortex3") || name.equals("composite"))
+            if (name.equals("composite"))
             {
                 return 3;
             }
@@ -1461,22 +1618,22 @@
                 return 6;
             }
 
-            if (name.equals("colortex4") || name.equals("gaux1"))
+            if (name.equals("gaux1"))
             {
                 return 7;
             }
 
-            if (name.equals("colortex5") || name.equals("gaux2"))
+            if (name.equals("gaux2"))
             {
                 return 8;
             }
 
-            if (name.equals("colortex6") || name.equals("gaux3"))
+            if (name.equals("gaux3"))
             {
                 return 9;
             }
 
-            if (name.equals("colortex7") || name.equals("gaux4"))
+            if (name.equals("gaux4"))
             {
                 return 10;
             }
@@ -1530,6 +1687,8 @@
                     GL11.glBindTexture(k, j);
                 }
             }
+
+            GlStateManager.activeTexture(33984);
         }
     }
 
@@ -1538,9 +1697,13 @@
         deleteCustomTextures(customTexturesGbuffers);
         deleteCustomTextures(customTexturesComposite);
         deleteCustomTextures(customTexturesDeferred);
+        deleteCustomTextures(customTexturesShadowcomp);
+        deleteCustomTextures(customTexturesPrepare);
         customTexturesGbuffers = null;
         customTexturesComposite = null;
         customTexturesDeferred = null;
+        customTexturesShadowcomp = null;
+        customTexturesPrepare = null;
     }
 
     private static void deleteCustomTextures(ICustomTexture[] cts)
@@ -1750,8 +1913,8 @@
         try
         {
             String[] astring = programs.getProgramNames();
-            ShaderOption[] ashaderoption = ShaderPackParser.parseShaderPackOptions(shaderPack, astring, shaderPackDimensions);
             Properties properties = loadOptionProperties(shaderPack);
+            ShaderOption[] ashaderoption = ShaderPackParser.parseShaderPackOptions(shaderPack, astring, shaderPackDimensions);
 
             for (int i = 0; i < ashaderoption.length; ++i)
             {
@@ -1841,9 +2004,7 @@
     public static ArrayList listOfShaders()
     {
         ArrayList<String> arraylist = new ArrayList<>();
-        arraylist.add("OFF");
-        arraylist.add("(internal)");
-        int i = arraylist.size();
+        ArrayList<String> arraylist1 = new ArrayList<>();
 
         try
         {
@@ -1854,9 +2015,9 @@
 
             File[] afile = shaderPacksDir.listFiles();
 
-            for (int j = 0; j < afile.length; ++j)
+            for (int i = 0; i < afile.length; ++i)
             {
-                File file1 = afile[j];
+                File file1 = afile[i];
                 String s = file1.getName();
 
                 if (file1.isDirectory())
@@ -1873,7 +2034,7 @@
                 }
                 else if (file1.isFile() && s.toLowerCase().endsWith(".zip"))
                 {
-                    arraylist.add(s);
+                    arraylist1.add(s);
                 }
             }
         }
@@ -1881,9 +2042,14 @@
         {
         }
 
-        List<String> list = arraylist.subList(i, arraylist.size());
-        Collections.sort(list, String.CASE_INSENSITIVE_ORDER);
-        return arraylist;
+        Collections.sort(arraylist, String.CASE_INSENSITIVE_ORDER);
+        Collections.sort(arraylist1, String.CASE_INSENSITIVE_ORDER);
+        ArrayList<String> arraylist2 = new ArrayList<>();
+        arraylist2.add("OFF");
+        arraylist2.add("(internal)");
+        arraylist2.addAll(arraylist);
+        arraylist2.addAll(arraylist1);
+        return arraylist2;
     }
 
     public static int checkFramebufferStatus(String location)
@@ -1892,7 +2058,7 @@
 
         if (i != 36053)
         {
-            System.err.format("FramebufferStatus 0x%04X at %s\n", i, location);
+            SMCLog.severe("FramebufferStatus 0x%04X at '%s'", i, location);
         }
 
         return i;
@@ -1955,7 +2121,7 @@
 
         if (location.equals("setDrawBuffers"))
         {
-            stringbuilder.append(", drawBuffers: " + activeProgram.getDrawBufSettings());
+            stringbuilder.append(", drawBuffers: " + ArrayUtils.arrayToString((Object[])activeProgram.getDrawBufSettings()));
         }
 
         return stringbuilder.toString();
@@ -2017,7 +2183,7 @@
         mc.ingameGUI.getChatGUI().printChatMessage(new StringTextComponent(str));
     }
 
-    private static void printChatAndLogError(String str)
+    public static void printChatAndLogError(String str)
     {
         SMCLog.severe(str);
         mc.ingameGUI.getChatGUI().printChatMessage(new StringTextComponent(str));
@@ -2051,10 +2217,17 @@
         SMCLog.info("Vendor:  " + glVendorString);
         SMCLog.info("Renderer: " + glRendererString);
         SMCLog.info("Capabilities: " + (capabilities.OpenGL20 ? " 2.0 " : " - ") + (capabilities.OpenGL21 ? " 2.1 " : " - ") + (capabilities.OpenGL30 ? " 3.0 " : " - ") + (capabilities.OpenGL32 ? " 3.2 " : " - ") + (capabilities.OpenGL40 ? " 4.0 " : " - "));
-        SMCLog.info("GL_MAX_DRAW_BUFFERS: " + GL32.glGetInteger(34852));
-        SMCLog.info("GL_MAX_COLOR_ATTACHMENTS_EXT: " + GL32.glGetInteger(36063));
-        SMCLog.info("GL_MAX_TEXTURE_IMAGE_UNITS: " + GL32.glGetInteger(34930));
+        SMCLog.info("GL_MAX_DRAW_BUFFERS: " + GL43.glGetInteger(34852));
+        SMCLog.info("GL_MAX_COLOR_ATTACHMENTS_EXT: " + GL43.glGetInteger(36063));
+        SMCLog.info("GL_MAX_TEXTURE_IMAGE_UNITS: " + GL43.glGetInteger(34930));
         hasGlGenMipmap = capabilities.OpenGL30;
+        glDebugGroups = Boolean.getBoolean("gl.debug.groups") && capabilities.GL_KHR_debug;
+
+        if (glDebugGroups)
+        {
+            SMCLog.info("glDebugGroups: true");
+        }
+
         loadConfig();
     }
 
@@ -2103,11 +2276,26 @@
         }
     }
 
+    public static boolean isRenderShadowTerrain()
+    {
+        return !shaderPackShadowTerrain.isFalse();
+    }
+
     public static boolean isRenderShadowTranslucent()
     {
         return !shaderPackShadowTranslucent.isFalse();
     }
 
+    public static boolean isRenderShadowEntities()
+    {
+        return !shaderPackShadowEntities.isFalse();
+    }
+
+    public static boolean isRenderShadowBlockEntities()
+    {
+        return !shaderPackShadowBlockEntities.isFalse();
+    }
+
     public static boolean isUnderwaterOverlay()
     {
         return !shaderPackUnderwaterOverlay.isFalse();
@@ -2200,21 +2388,21 @@
                 printChatAndLogError("No EXT_framebuffer_object");
             }
 
-            ((Buffer)dfbDrawBuffers).position(0).limit(8);
-            ((Buffer)dfbColorTextures).position(0).limit(16);
-            ((Buffer)dfbDepthTextures).position(0).limit(3);
-            ((Buffer)sfbDrawBuffers).position(0).limit(8);
-            ((Buffer)sfbDepthTextures).position(0).limit(2);
-            ((Buffer)sfbColorTextures).position(0).limit(8);
+            dfbDrawBuffers.position(0).limit(8);
+            sfbDrawBuffers.position(0).limit(8);
             usedColorBuffers = 4;
             usedDepthBuffers = 1;
             usedShadowColorBuffers = 0;
             usedShadowDepthBuffers = 0;
             usedColorAttachs = 1;
             usedDrawBuffers = 1;
+            bindImageTextures = false;
             Arrays.fill(gbuffersFormat, 6408);
             Arrays.fill(gbuffersClear, true);
             Arrays.fill(gbuffersClearColor, (Object)null);
+            Arrays.fill(shadowBuffersFormat, 6408);
+            Arrays.fill(shadowBuffersClear, true);
+            Arrays.fill(shadowBuffersClearColor, (Object)null);
             Arrays.fill(shadowHardwareFilteringEnabled, false);
             Arrays.fill(shadowMipmapEnabled, false);
             Arrays.fill(shadowFilterNearest, false);
@@ -2236,6 +2424,7 @@
             useEntityAttrib = false;
             useMidTexCoordAttrib = false;
             useTangentAttrib = false;
+            useVelocityAttrib = false;
             waterShadowEnabled = false;
             hasGeometryShaders = false;
             updateBlockLightLevel();
@@ -2260,6 +2449,8 @@
                 }
             }
 
+            loadShaderPackDynamicProperties();
+
             for (int k = 0; k < ProgramsAll.length; ++k)
             {
                 Program program = ProgramsAll[k];
@@ -2293,6 +2484,9 @@
                     String s4 = s3 + ".vsh";
                     String s5 = s3 + ".gsh";
                     String s6 = s3 + ".fsh";
+                    ComputeProgram[] acomputeprogram = setupComputePrograms(program, "/shaders/", s2, ".csh");
+                    program.setComputePrograms(acomputeprogram);
+                    Config.sleep(10L);
                     setupProgram(program, s4, s5, s6);
                     int j = program.getId();
 
@@ -2302,56 +2496,56 @@
                     }
 
                     initDrawBuffers(program);
+                    initBlendStatesIndexed(program);
                     updateToggleBuffers(program);
+                    updateProgramSize(program);
                 }
             }
 
-            hasDeferredPrograms = false;
+            hasDeferredPrograms = ProgramUtils.hasActive(ProgramsDeferred);
+            hasShadowcompPrograms = ProgramUtils.hasActive(ProgramsShadowcomp);
+            hasPreparePrograms = ProgramUtils.hasActive(ProgramsPrepare);
+            usedColorAttachs = usedColorBuffers;
 
-            for (int l = 0; l < ProgramsDeferred.length; ++l)
+            if (usedShadowDepthBuffers > 0 || usedShadowColorBuffers > 0)
             {
-                if (ProgramsDeferred[l].getId() != 0)
-                {
-                    hasDeferredPrograms = true;
-                    break;
-                }
+                hasShadowMap = true;
+                usedShadowDepthBuffers = Math.max(usedShadowDepthBuffers, 1);
             }
 
-            usedColorAttachs = usedColorBuffers;
-            shadowPassInterval = usedShadowDepthBuffers > 0 ? 1 : 0;
-            shouldSkipDefaultShadow = usedShadowDepthBuffers > 0;
+            shouldSkipDefaultShadow = hasShadowMap;
             SMCLog.info("usedColorBuffers: " + usedColorBuffers);
             SMCLog.info("usedDepthBuffers: " + usedDepthBuffers);
             SMCLog.info("usedShadowColorBuffers: " + usedShadowColorBuffers);
             SMCLog.info("usedShadowDepthBuffers: " + usedShadowDepthBuffers);
             SMCLog.info("usedColorAttachs: " + usedColorAttachs);
             SMCLog.info("usedDrawBuffers: " + usedDrawBuffers);
-            ((Buffer)dfbDrawBuffers).position(0).limit(usedDrawBuffers);
-            ((Buffer)dfbColorTextures).position(0).limit(usedColorBuffers * 2);
-            dfbColorTexturesFlip.reset();
+            SMCLog.info("bindImageTextures: " + bindImageTextures);
+            int l = GL43.glGetInteger(34852);
 
-            for (int i1 = 0; i1 < usedDrawBuffers; ++i1)
+            if (usedDrawBuffers > l)
             {
-                dfbDrawBuffers.put(i1, 36064 + i1);
+                printChatAndLogError("[Shaders] Error: Not enough draw buffers, needed: " + usedDrawBuffers + ", available: " + l);
+                usedDrawBuffers = l;
             }
 
-            int j1 = GL32.glGetInteger(34852);
+            dfbDrawBuffers.position(0).limit(usedDrawBuffers);
 
-            if (usedDrawBuffers > j1)
+            for (int i1 = 0; i1 < usedDrawBuffers; ++i1)
             {
-                printChatAndLogError("[Shaders] Error: Not enough draw buffers, needed: " + usedDrawBuffers + ", available: " + j1);
+                dfbDrawBuffers.put(i1, 36064 + i1);
             }
 
-            ((Buffer)sfbDrawBuffers).position(0).limit(usedShadowColorBuffers);
+            sfbDrawBuffers.position(0).limit(usedShadowColorBuffers);
 
-            for (int k1 = 0; k1 < usedShadowColorBuffers; ++k1)
+            for (int j1 = 0; j1 < usedShadowColorBuffers; ++j1)
             {
-                sfbDrawBuffers.put(k1, 36064 + k1);
+                sfbDrawBuffers.put(j1, 36064 + j1);
             }
 
-            for (int l1 = 0; l1 < ProgramsAll.length; ++l1)
+            for (int k1 = 0; k1 < ProgramsAll.length; ++k1)
             {
-                Program program1 = ProgramsAll[l1];
+                Program program1 = ProgramsAll[k1];
                 Program program2;
 
                 for (program2 = program1; program2.getId() == 0 && program2.getProgramBackup() != program2; program2 = program2.getProgramBackup())
@@ -2390,17 +2584,19 @@
             }
 
             checkGLError("Shaders.init");
+
+            mc.stereoProvider.reinitFrameBuffers("Shaders Initialized");
         }
     }
 
     private static void initDrawBuffers(Program p)
     {
-        int i = GL32.glGetInteger(34852);
+        int i = GL43.glGetInteger(34852);
         Arrays.fill(p.getToggleColorTextures(), false);
 
         if (p == ProgramFinal)
         {
-            p.setDrawBuffers((IntBuffer)null);
+            p.setDrawBuffers((DrawBuffers)null);
         }
         else if (p.getId() == 0)
         {
@@ -2410,19 +2606,19 @@
             }
             else
             {
-                p.setDrawBuffers(drawBuffersColorAtt0);
+                p.setDrawBuffers(drawBuffersColorAtt[0]);
             }
         }
         else
         {
-            String s = p.getDrawBufSettings();
+            String[] astring = p.getDrawBufSettings();
 
-            if (s == null)
+            if (astring == null)
             {
                 if (p != ProgramShadow && p != ProgramShadowSolid && p != ProgramShadowCutout)
                 {
                     p.setDrawBuffers(dfbDrawBuffers);
-                    usedDrawBuffers = usedColorBuffers;
+                    usedDrawBuffers = Math.min(usedColorBuffers, i);
                     Arrays.fill(p.getToggleColorTextures(), 0, usedColorBuffers, true);
                 }
                 else
@@ -2432,56 +2628,86 @@
             }
             else
             {
-                IntBuffer intbuffer = p.getDrawBuffersBuffer();
-                int j = s.length();
+                DrawBuffers drawbuffers = p.getDrawBuffersCustom();
+                int j = astring.length;
                 usedDrawBuffers = Math.max(usedDrawBuffers, j);
                 j = Math.min(j, i);
-                p.setDrawBuffers(intbuffer);
-                ((Buffer)intbuffer).limit(j);
+                p.setDrawBuffers(drawbuffers);
+                drawbuffers.limit(j);
 
                 for (int k = 0; k < j; ++k)
                 {
-                    int l = getDrawBuffer(p, s, k);
-                    intbuffer.put(k, l);
+                    int l = getDrawBuffer(p, astring[k]);
+                    drawbuffers.put(k, l);
+                }
+
+                String s = drawbuffers.getInfo(false);
+                String s1 = drawbuffers.getInfo(true);
+
+                if (!Config.equals(s, s1))
+                {
+                    SMCLog.info("Draw buffers: " + s + " -> " + s1);
                 }
             }
         }
     }
 
-    private static int getDrawBuffer(Program p, String str, int i)
+    private static void initBlendStatesIndexed(Program p)
     {
-        int d = 0;
+        GlBlendState[] aglblendstate = p.getBlendStatesColorIndexed();
 
-        if (i >= str.length())
-        {
-            return d;
-        }
-        else
+        if (aglblendstate != null)
         {
-            int j = str.charAt(i) - 48;
-
-            if (p == ProgramShadow)
+            for (int i = 0; i < aglblendstate.length; ++i)
             {
-                if (j >= 0 && j <= 1)
+                GlBlendState glblendstate = aglblendstate[i];
+
+                if (glblendstate != null)
                 {
-                    i = j + 36064;
-                    usedShadowColorBuffers = Math.max(usedShadowColorBuffers, j);
-                }
+                    String s = Integer.toHexString(i).toUpperCase();
+                    int j = 36064 + i;
+                    int k = p.getDrawBuffers().indexOf(j);
 
-                return i;
+                    if (k < 0)
+                    {
+                        SMCLog.warning("Blend buffer not used in draw buffers: " + s);
+                    }
+                    else
+                    {
+                        p.setBlendStateIndexed(k, glblendstate);
+                        SMCLog.info("Blend buffer: " + s);
+                    }
+                }
             }
-            else
+        }
+    }
+
+    private static int getDrawBuffer(Program p, String str)
+    {
+        int i = 0;
+        int j = Config.parseInt(str, -1);
+
+        if (p == ProgramShadow)
+        {
+            if (j >= 0 && j < 2)
             {
-                if (j >= 0 && j <= 7)
-                {
-                    p.getToggleColorTextures()[j] = true;
-                    i = j + 36064;
-                    usedColorAttachs = Math.max(usedColorAttachs, j);
-                    usedColorBuffers = Math.max(usedColorBuffers, j);
-                }
+                i = 36064 + j;
+                usedShadowColorBuffers = Math.max(usedShadowColorBuffers, j + 1);
+            }
 
-                return i;
+            return i;
+        }
+        else
+        {
+            if (j >= 0 && j < 16)
+            {
+                p.getToggleColorTextures()[j] = true;
+                i = 36064 + j;
+                usedColorAttachs = Math.max(usedColorAttachs, j + 1);
+                usedColorBuffers = Math.max(usedColorBuffers, j + 1);
             }
+
+            return i;
         }
     }
 
@@ -2501,6 +2727,58 @@
         }
     }
 
+    private static void updateProgramSize(Program p)
+    {
+        if (p.getProgramStage().isMainComposite())
+        {
+            DynamicDimension dynamicdimension = null;
+            int i = 0;
+            int j = 0;
+            DrawBuffers drawbuffers = p.getDrawBuffers();
+
+            if (drawbuffers != null)
+            {
+                for (int k = 0; k < drawbuffers.limit(); ++k)
+                {
+                    int l = drawbuffers.get(k);
+                    int i1 = l - 36064;
+
+                    if (i1 >= 0 && i1 < colorBufferSizes.length)
+                    {
+                        DynamicDimension dynamicdimension1 = colorBufferSizes[i1];
+
+                        if (dynamicdimension1 != null)
+                        {
+                            ++i;
+
+                            if (dynamicdimension == null)
+                            {
+                                dynamicdimension = dynamicdimension1;
+                            }
+
+                            if (dynamicdimension1.equals(dynamicdimension))
+                            {
+                                ++j;
+                            }
+                        }
+                    }
+                }
+
+                if (i != 0)
+                {
+                    if (j != drawbuffers.limit())
+                    {
+                        SMCLog.severe("Program " + p.getName() + " draws to buffers with different sizes");
+                    }
+                    else
+                    {
+                        p.setDrawSize(dynamicdimension);
+                    }
+                }
+            }
+        }
+    }
+
     public static void resetDisplayLists()
     {
         SMCLog.info("Reset model renderers");
@@ -2512,573 +2790,869 @@
     private static void setupProgram(Program program, String vShaderPath, String gShaderPath, String fShaderPath)
     {
         checkGLError("pre setupProgram");
-        int i = ARBShaderObjects.glCreateProgramObjectARB();
+        progUseEntityAttrib = false;
+        progUseMidTexCoordAttrib = false;
+        progUseTangentAttrib = false;
+        progUseVelocityAttrib = false;
+        progUseMidBlockAttrib = false;
+        int i = createVertShader(program, vShaderPath);
+        int j = createGeomShader(program, gShaderPath);
+        int k = createFragShader(program, fShaderPath);
         checkGLError("create");
 
-        if (i != 0)
+        if (i != 0 || j != 0 || k != 0)
         {
-            progUseEntityAttrib = false;
-            progUseMidTexCoordAttrib = false;
-            progUseTangentAttrib = false;
-            int j = createVertShader(program, vShaderPath);
-            int k = createGeomShader(program, gShaderPath);
-            int l = createFragShader(program, fShaderPath);
+            int l = ARBShaderObjects.glCreateProgramObjectARB();
             checkGLError("create");
 
-            if (j == 0 && k == 0 && l == 0)
+            if (i != 0)
             {
-                ARBShaderObjects.glDeleteObjectARB(i);
-                i = 0;
-                program.resetId();
+                ARBShaderObjects.glAttachObjectARB(l, i);
+                checkGLError("attach");
             }
-            else
+
+            if (j != 0)
             {
-                if (j != 0)
+                ARBShaderObjects.glAttachObjectARB(l, j);
+                checkGLError("attach");
+
+                if (progArbGeometryShader4)
                 {
-                    ARBShaderObjects.glAttachObjectARB(i, j);
-                    checkGLError("attach");
+                    ARBGeometryShader4.glProgramParameteriARB(l, 36315, 4);
+                    ARBGeometryShader4.glProgramParameteriARB(l, 36316, 5);
+                    ARBGeometryShader4.glProgramParameteriARB(l, 36314, progMaxVerticesOut);
+                    checkGLError("arbGeometryShader4");
                 }
 
-                if (k != 0)
+                if (progExtGeometryShader4)
                 {
-                    ARBShaderObjects.glAttachObjectARB(i, k);
-                    checkGLError("attach");
+                    EXTGeometryShader4.glProgramParameteriEXT(l, 36315, 4);
+                    EXTGeometryShader4.glProgramParameteriEXT(l, 36316, 5);
+                    EXTGeometryShader4.glProgramParameteriEXT(l, 36314, progMaxVerticesOut);
+                    checkGLError("extGeometryShader4");
+                }
 
-                    if (progArbGeometryShader4)
-                    {
-                        ARBGeometryShader4.glProgramParameteriARB(i, 36315, 4);
-                        ARBGeometryShader4.glProgramParameteriARB(i, 36316, 5);
-                        ARBGeometryShader4.glProgramParameteriARB(i, 36314, progMaxVerticesOut);
-                        checkGLError("arbGeometryShader4");
-                    }
+                hasGeometryShaders = true;
+            }
 
-                    hasGeometryShaders = true;
-                }
+            if (k != 0)
+            {
+                ARBShaderObjects.glAttachObjectARB(l, k);
+                checkGLError("attach");
+            }
 
-                if (l != 0)
-                {
-                    ARBShaderObjects.glAttachObjectARB(i, l);
-                    checkGLError("attach");
-                }
+            if (progUseEntityAttrib)
+            {
+                ARBVertexShader.glBindAttribLocationARB(l, entityAttrib, "mc_Entity");
+                checkGLError("mc_Entity");
+            }
 
-                if (progUseEntityAttrib)
-                {
-                    ARBVertexShader.glBindAttribLocationARB(i, entityAttrib, "mc_Entity");
-                    checkGLError("mc_Entity");
-                }
+            if (progUseMidTexCoordAttrib)
+            {
+                ARBVertexShader.glBindAttribLocationARB(l, midTexCoordAttrib, "mc_midTexCoord");
+                checkGLError("mc_midTexCoord");
+            }
 
-                if (progUseMidTexCoordAttrib)
-                {
-                    ARBVertexShader.glBindAttribLocationARB(i, midTexCoordAttrib, "mc_midTexCoord");
-                    checkGLError("mc_midTexCoord");
-                }
+            if (progUseTangentAttrib)
+            {
+                ARBVertexShader.glBindAttribLocationARB(l, tangentAttrib, "at_tangent");
+                checkGLError("at_tangent");
+            }
 
-                if (progUseTangentAttrib)
-                {
-                    ARBVertexShader.glBindAttribLocationARB(i, tangentAttrib, "at_tangent");
-                    checkGLError("at_tangent");
-                }
+            if (progUseVelocityAttrib)
+            {
+                ARBVertexShader.glBindAttribLocationARB(l, velocityAttrib, "at_velocity");
+                checkGLError("at_velocity");
+            }
 
-                ARBShaderObjects.glLinkProgramARB(i);
+            if (progUseMidBlockAttrib)
+            {
+                ARBVertexShader.glBindAttribLocationARB(l, midBlockAttrib, "at_midBlock");
+                checkGLError("at_midBlock");
+            }
 
-                if (GL32.glGetProgrami(i, 35714) != 1)
-                {
-                    SMCLog.severe("Error linking program: " + i + " (" + program.getName() + ")");
-                }
+            ARBShaderObjects.glLinkProgramARB(l);
 
-                printLogInfo(i, program.getName());
+            if (GL43.glGetProgrami(l, 35714) != 1)
+            {
+                SMCLog.severe("Error linking program: " + l + " (" + program.getName() + ")");
+            }
 
-                if (j != 0)
-                {
-                    ARBShaderObjects.glDetachObjectARB(i, j);
-                    ARBShaderObjects.glDeleteObjectARB(j);
-                }
+            printLogInfo(l, program.getName());
 
-                if (k != 0)
-                {
-                    ARBShaderObjects.glDetachObjectARB(i, k);
-                    ARBShaderObjects.glDeleteObjectARB(k);
-                }
+            if (i != 0)
+            {
+                ARBShaderObjects.glDetachObjectARB(l, i);
+                ARBShaderObjects.glDeleteObjectARB(i);
+            }
 
-                if (l != 0)
-                {
-                    ARBShaderObjects.glDetachObjectARB(i, l);
-                    ARBShaderObjects.glDeleteObjectARB(l);
-                }
+            if (j != 0)
+            {
+                ARBShaderObjects.glDetachObjectARB(l, j);
+                ARBShaderObjects.glDeleteObjectARB(j);
+            }
 
-                program.setId(i);
-                program.setRef(i);
-                useProgram(program);
-                ARBShaderObjects.glValidateProgramARB(i);
-                useProgram(ProgramNone);
-                printLogInfo(i, program.getName());
-                int i1 = GL32.glGetProgrami(i, 35715);
-
-                if (i1 != 1)
-                {
-                    String s = "\"";
-                    printChatAndLogError("[Shaders] Error: Invalid program " + s + program.getName() + s);
-                    ARBShaderObjects.glDeleteObjectARB(i);
-                    i = 0;
-                    program.resetId();
-                }
+            if (k != 0)
+            {
+                ARBShaderObjects.glDetachObjectARB(l, k);
+                ARBShaderObjects.glDeleteObjectARB(k);
+            }
+
+            program.setId(l);
+            program.setRef(l);
+            useProgram(program);
+            ARBShaderObjects.glValidateProgramARB(l);
+            useProgram(ProgramNone);
+            printLogInfo(l, program.getName());
+            int i1 = GL43.glGetProgrami(l, 35715);
+
+            if (i1 != 1)
+            {
+                String s = "\"";
+                printChatAndLogError("[Shaders] Error: Invalid program " + s + program.getName() + s);
+                ARBShaderObjects.glDeleteObjectARB(l);
+                l = 0;
+                program.resetId();
             }
         }
     }
 
-    private static int createVertShader(Program program, String filename)
+    private static ComputeProgram[] setupComputePrograms(Program program, String prefixShaders, String programPath, String shaderExt)
     {
-        int i = ARBShaderObjects.glCreateShaderObjectARB(ARBVertexShader.GL_VERTEX_SHADER_ARB);
-
-        if (i == 0)
+        if (program.getProgramStage() == ProgramStage.GBUFFERS)
         {
-            return 0;
+            return new ComputeProgram[0];
         }
         else
         {
-            StringBuilder stringbuilder = new StringBuilder(131072);
-            BufferedReader bufferedreader = null;
+            List<ComputeProgram> list = new ArrayList<>();
+            int i = 27;
 
-            try
+            for (int j = 0; j < i; ++j)
             {
-                bufferedreader = new BufferedReader(getShaderReader(filename));
+                String s = j > 0 ? "_" + (char)(97 + j - 1) : "";
+                String s1 = programPath + s;
+                String s2 = prefixShaders + s1 + shaderExt;
+                ComputeProgram computeprogram = new ComputeProgram(program.getName(), program.getProgramStage());
+                setupComputeProgram(computeprogram, s2);
+
+                if (computeprogram.getId() > 0)
+                {
+                    list.add(computeprogram);
+                    SMCLog.info("Compute program loaded: " + s1);
+                }
             }
-            catch (Exception exception)
+
+            return list.toArray(new ComputeProgram[list.size()]);
+        }
+    }
+
+    private static void setupComputeProgram(ComputeProgram program, String cShaderPath)
+    {
+        checkGLError("pre setupProgram");
+        int i = createCompShader(program, cShaderPath);
+        checkGLError("create");
+
+        if (i != 0)
+        {
+            int j = ARBShaderObjects.glCreateProgramObjectARB();
+            checkGLError("create");
+
+            if (i != 0)
             {
-                ARBShaderObjects.glDeleteObjectARB(i);
-                return 0;
+                ARBShaderObjects.glAttachObjectARB(j, i);
+                checkGLError("attach");
             }
 
-            ShaderOption[] ashaderoption = getChangedOptions(shaderPackOptions);
-            List<String> list = new ArrayList<>();
+            ARBShaderObjects.glLinkProgramARB(j);
 
-            if (bufferedreader != null)
+            if (GL43.glGetProgrami(j, 35714) != 1)
             {
-                try
-                {
-                    bufferedreader = ShaderPackParser.resolveIncludes(bufferedreader, filename, shaderPack, 0, list, 0);
-                    MacroState macrostate = new MacroState();
+                SMCLog.severe("Error linking program: " + j + " (" + program.getName() + ")");
+            }
 
-                    while (true)
-                    {
-                        String s = bufferedreader.readLine();
+            printLogInfo(j, program.getName());
 
-                        if (s == null)
-                        {
-                            bufferedreader.close();
-                            break;
-                        }
+            if (i != 0)
+            {
+                ARBShaderObjects.glDetachObjectARB(j, i);
+                ARBShaderObjects.glDeleteObjectARB(i);
+            }
+
+            program.setId(j);
+            program.setRef(j);
+            ARBShaderObjects.glUseProgramObjectARB(j);
+            ARBShaderObjects.glValidateProgramARB(j);
+            ARBShaderObjects.glUseProgramObjectARB(0);
+            printLogInfo(j, program.getName());
+            int k = GL43.glGetProgrami(j, 35715);
+
+            if (k != 1)
+            {
+                String s = "\"";
+                printChatAndLogError("[Shaders] Error: Invalid program " + s + program.getName() + s);
+                ARBShaderObjects.glDeleteObjectARB(j);
+                j = 0;
+                program.resetId();
+            }
+        }
+    }
+
+    private static int createCompShader(ComputeProgram program, String filename)
+    {
+        InputStream inputstream = shaderPack.getResourceAsStream(filename);
 
-                        s = applyOptions(s, ashaderoption);
-                        stringbuilder.append(s).append('\n');
+        if (inputstream == null)
+        {
+            return 0;
+        }
+        else
+        {
+            int i = ARBShaderObjects.glCreateShaderObjectARB(37305);
 
-                        if (macrostate.processLine(s))
+            if (i == 0)
+            {
+                return 0;
+            }
+            else
+            {
+                ShaderOption[] ashaderoption = getChangedOptions(shaderPackOptions);
+                List<String> list = new ArrayList<>();
+                LineBuffer linebuffer = new LineBuffer();
+
+                if (linebuffer != null)
+                {
+                    try
+                    {
+                        LineBuffer linebuffer1 = LineBuffer.readAll(new InputStreamReader(inputstream));
+                        linebuffer1 = ShaderPackParser.resolveIncludes(linebuffer1, filename, shaderPack, 0, list, 0);
+                        MacroState macrostate = new MacroState();
+
+                        for (String s : linebuffer1)
                         {
-                            ShaderLine shaderline = ShaderParser.parseLine(s);
+                            s = applyOptions(s, ashaderoption);
+                            linebuffer.add(s);
 
-                            if (shaderline != null)
+                            if (macrostate.processLine(s))
                             {
-                                if (shaderline.isAttribute("mc_Entity"))
-                                {
-                                    useEntityAttrib = true;
-                                    progUseEntityAttrib = true;
-                                }
-                                else if (shaderline.isAttribute("mc_midTexCoord"))
-                                {
-                                    useMidTexCoordAttrib = true;
-                                    progUseMidTexCoordAttrib = true;
-                                }
-                                else if (shaderline.isAttribute("at_tangent"))
-                                {
-                                    useTangentAttrib = true;
-                                    progUseTangentAttrib = true;
-                                }
+                                ShaderLine shaderline = ShaderParser.parseLine(s);
 
-                                if (shaderline.isConstInt("countInstances"))
+                                if (shaderline != null)
                                 {
-                                    program.setCountInstances(shaderline.getValueInt());
-                                    SMCLog.info("countInstances: " + program.getCountInstances());
+                                    if (shaderline.isUniform())
+                                    {
+                                        String s1 = shaderline.getName();
+                                        int j;
+
+                                        if ((j = ShaderParser.getShadowDepthIndex(s1)) >= 0)
+                                        {
+                                            usedShadowDepthBuffers = Math.max(usedShadowDepthBuffers, j + 1);
+                                        }
+                                        else if ((j = ShaderParser.getShadowColorIndex(s1)) >= 0)
+                                        {
+                                            usedShadowColorBuffers = Math.max(usedShadowColorBuffers, j + 1);
+                                        }
+                                        else if ((j = ShaderParser.getShadowColorImageIndex(s1)) >= 0)
+                                        {
+                                            usedShadowColorBuffers = Math.max(usedShadowColorBuffers, j + 1);
+                                            bindImageTextures = true;
+                                        }
+                                        else if ((j = ShaderParser.getDepthIndex(s1)) >= 0)
+                                        {
+                                            usedDepthBuffers = Math.max(usedDepthBuffers, j + 1);
+                                        }
+                                        else if ((j = ShaderParser.getColorIndex(s1)) >= 0)
+                                        {
+                                            usedColorBuffers = Math.max(usedColorBuffers, j + 1);
+                                        }
+                                        else if ((j = ShaderParser.getColorImageIndex(s1)) >= 0)
+                                        {
+                                            usedColorBuffers = Math.max(usedColorBuffers, j + 1);
+                                            bindImageTextures = true;
+                                        }
+                                    }
+                                    else if (shaderline.isLayout("in"))
+                                    {
+                                        Vector3i vector3i = ShaderParser.parseLocalSize(shaderline.getValue());
+
+                                        if (vector3i != null)
+                                        {
+                                            program.setLocalSize(vector3i);
+                                        }
+                                        else
+                                        {
+                                            SMCLog.severe("Invalid local size: " + s);
+                                        }
+                                    }
+                                    else if (shaderline.isConstIVec3("workGroups"))
+                                    {
+                                        Vector3i vector3i1 = shaderline.getValueIVec3();
+
+                                        if (vector3i1 != null)
+                                        {
+                                            program.setWorkGroups(vector3i1);
+                                        }
+                                        else
+                                        {
+                                            SMCLog.severe("Invalid workGroups: " + s);
+                                        }
+                                    }
+                                    else if (shaderline.isConstVec2("workGroupsRender"))
+                                    {
+                                        Vector2f vector2f = shaderline.getValueVec2();
+
+                                        if (vector2f != null)
+                                        {
+                                            program.setWorkGroupsRender(vector2f);
+                                        }
+                                        else
+                                        {
+                                            SMCLog.severe("Invalid workGroupsRender: " + s);
+                                        }
+                                    }
+                                    else if (shaderline.isConstBoolSuffix("MipmapEnabled", true))
+                                    {
+                                        String s3 = StrUtils.removeSuffix(shaderline.getName(), "MipmapEnabled");
+                                        int l = getBufferIndex(s3);
+
+                                        if (l >= 0)
+                                        {
+                                            int k = program.getCompositeMipmapSetting();
+                                            k = k | 1 << l;
+                                            program.setCompositeMipmapSetting(k);
+                                            SMCLog.info("%s mipmap enabled", s3);
+                                        }
+                                    }
                                 }
                             }
                         }
                     }
+                    catch (Exception exception)
+                    {
+                        SMCLog.severe("Couldn't read " + filename + "!");
+                        exception.printStackTrace();
+                        ARBShaderObjects.glDeleteObjectARB(i);
+                        return 0;
+                    }
                 }
-                catch (Exception exception1)
+
+                String s2 = linebuffer.toString();
+
+                if (saveFinalShaders)
+                {
+                    saveShader(filename, s2);
+                }
+
+                if (program.getLocalSize() == null)
                 {
-                    SMCLog.severe("Couldn't read " + filename + "!");
-                    exception1.printStackTrace();
-                    ARBShaderObjects.glDeleteObjectARB(i);
+                    SMCLog.severe("Missing local size: " + filename);
+                    GL43.glDeleteShader(i);
                     return 0;
                 }
-            }
+                else
+                {
+                    ARBShaderObjects.glShaderSourceARB(i, (CharSequence)s2);
+                    ARBShaderObjects.glCompileShaderARB(i);
 
-            if (saveFinalShaders)
-            {
-                saveShader(filename, stringbuilder.toString());
+                    if (GL43.glGetShaderi(i, 35713) != 1)
+                    {
+                        SMCLog.severe("Error compiling compute shader: " + filename);
+                    }
+
+                    printShaderLogInfo(i, filename, list);
+                    return i;
+                }
             }
+        }
+    }
+
+    private static int createVertShader(Program program, String filename)
+    {
+        InputStream inputstream = shaderPack.getResourceAsStream(filename);
 
-            ARBShaderObjects.glShaderSourceARB(i, (CharSequence)stringbuilder);
-            ARBShaderObjects.glCompileShaderARB(i);
+        if (inputstream == null)
+        {
+            return 0;
+        }
+        else
+        {
+            int i = ARBShaderObjects.glCreateShaderObjectARB(ARBVertexShader.GL_VERTEX_SHADER_ARB);
 
-            if (GL32.glGetShaderi(i, 35713) != 1)
+            if (i == 0)
             {
-                SMCLog.severe("Error compiling vertex shader: " + filename);
+                return 0;
             }
+            else
+            {
+                ShaderOption[] ashaderoption = getChangedOptions(shaderPackOptions);
+                List<String> list = new ArrayList<>();
+                LineBuffer linebuffer = new LineBuffer();
 
-            printShaderLogInfo(i, filename, list);
-            return i;
+                if (linebuffer != null)
+                {
+                    try
+                    {
+                        LineBuffer linebuffer1 = LineBuffer.readAll(new InputStreamReader(inputstream));
+                        linebuffer1 = ShaderPackParser.resolveIncludes(linebuffer1, filename, shaderPack, 0, list, 0);
+                        linebuffer1 = ShaderPackParser.remapTextureUnits(linebuffer1);
+                        MacroState macrostate = new MacroState();
+
+                        for (String s : linebuffer1)
+                        {
+                            s = applyOptions(s, ashaderoption);
+                            linebuffer.add(s);
+
+                            if (macrostate.processLine(s))
+                            {
+                                ShaderLine shaderline = ShaderParser.parseLine(s);
+
+                                if (shaderline != null)
+                                {
+                                    if (shaderline.isAttribute("mc_Entity"))
+                                    {
+                                        useEntityAttrib = true;
+                                        progUseEntityAttrib = true;
+                                    }
+                                    else if (shaderline.isAttribute("mc_midTexCoord"))
+                                    {
+                                        useMidTexCoordAttrib = true;
+                                        progUseMidTexCoordAttrib = true;
+                                    }
+                                    else if (shaderline.isAttribute("at_tangent"))
+                                    {
+                                        useTangentAttrib = true;
+                                        progUseTangentAttrib = true;
+                                    }
+                                    else if (shaderline.isAttribute("at_velocity"))
+                                    {
+                                        useVelocityAttrib = true;
+                                        progUseVelocityAttrib = true;
+                                    }
+                                    else if (shaderline.isAttribute("at_midBlock"))
+                                    {
+                                        useMidBlockAttrib = true;
+                                        progUseMidBlockAttrib = true;
+                                    }
+
+                                    if (shaderline.isConstInt("countInstances"))
+                                    {
+                                        program.setCountInstances(shaderline.getValueInt());
+                                        SMCLog.info("countInstances: " + program.getCountInstances());
+                                    }
+                                }
+                            }
+                        }
+                    }
+                    catch (Exception exception)
+                    {
+                        SMCLog.severe("Couldn't read " + filename + "!");
+                        exception.printStackTrace();
+                        ARBShaderObjects.glDeleteObjectARB(i);
+                        return 0;
+                    }
+                }
+
+                String s1 = linebuffer.toString();
+
+                if (saveFinalShaders)
+                {
+                    saveShader(filename, s1);
+                }
+
+                ARBShaderObjects.glShaderSourceARB(i, (CharSequence)s1);
+                ARBShaderObjects.glCompileShaderARB(i);
+
+                if (GL43.glGetShaderi(i, 35713) != 1)
+                {
+                    SMCLog.severe("Error compiling vertex shader: " + filename);
+                }
+
+                printShaderLogInfo(i, filename, list);
+                return i;
+            }
         }
     }
 
     private static int createGeomShader(Program program, String filename)
     {
-        int i = ARBShaderObjects.glCreateShaderObjectARB(36313);
+        InputStream inputstream = shaderPack.getResourceAsStream(filename);
 
-        if (i == 0)
+        if (inputstream == null)
         {
             return 0;
         }
         else
         {
-            StringBuilder stringbuilder = new StringBuilder(131072);
-            BufferedReader bufferedreader = null;
+            int i = ARBShaderObjects.glCreateShaderObjectARB(36313);
 
-            try
-            {
-                bufferedreader = new BufferedReader(getShaderReader(filename));
-            }
-            catch (Exception exception)
+            if (i == 0)
             {
-                ARBShaderObjects.glDeleteObjectARB(i);
                 return 0;
             }
-
-            ShaderOption[] ashaderoption = getChangedOptions(shaderPackOptions);
-            List<String> list = new ArrayList<>();
-            progArbGeometryShader4 = false;
-            progMaxVerticesOut = 3;
-
-            if (bufferedreader != null)
+            else
             {
-                try
-                {
-                    bufferedreader = ShaderPackParser.resolveIncludes(bufferedreader, filename, shaderPack, 0, list, 0);
-                    MacroState macrostate = new MacroState();
+                ShaderOption[] ashaderoption = getChangedOptions(shaderPackOptions);
+                List<String> list = new ArrayList<>();
+                progArbGeometryShader4 = false;
+                progExtGeometryShader4 = false;
+                progMaxVerticesOut = 3;
+                LineBuffer linebuffer = new LineBuffer();
 
-                    while (true)
+                if (linebuffer != null)
+                {
+                    try
                     {
-                        String s = bufferedreader.readLine();
+                        LineBuffer linebuffer1 = LineBuffer.readAll(new InputStreamReader(inputstream));
+                        linebuffer1 = ShaderPackParser.resolveIncludes(linebuffer1, filename, shaderPack, 0, list, 0);
+                        MacroState macrostate = new MacroState();
 
-                        if (s == null)
+                        for (String s : linebuffer1)
                         {
-                            bufferedreader.close();
-                            break;
-                        }
+                            s = applyOptions(s, ashaderoption);
+                            linebuffer.add(s);
 
-                        s = applyOptions(s, ashaderoption);
-                        stringbuilder.append(s).append('\n');
-
-                        if (macrostate.processLine(s))
-                        {
-                            ShaderLine shaderline = ShaderParser.parseLine(s);
-
-                            if (shaderline != null)
+                            if (macrostate.processLine(s))
                             {
-                                if (shaderline.isExtension("GL_ARB_geometry_shader4"))
+                                ShaderLine shaderline = ShaderParser.parseLine(s);
+
+                                if (shaderline != null)
                                 {
-                                    String s1 = Config.normalize(shaderline.getValue());
+                                    if (shaderline.isExtension("GL_ARB_geometry_shader4"))
+                                    {
+                                        String s1 = Config.normalize(shaderline.getValue());
+
+                                        if (s1.equals("enable") || s1.equals("require") || s1.equals("warn"))
+                                        {
+                                            progArbGeometryShader4 = true;
+                                        }
+                                    }
 
-                                    if (s1.equals("enable") || s1.equals("require") || s1.equals("warn"))
+                                    if (shaderline.isExtension("GL_EXT_geometry_shader4"))
                                     {
-                                        progArbGeometryShader4 = true;
+                                        String s3 = Config.normalize(shaderline.getValue());
+
+                                        if (s3.equals("enable") || s3.equals("require") || s3.equals("warn"))
+                                        {
+                                            progExtGeometryShader4 = true;
+                                        }
                                     }
-                                }
 
-                                if (shaderline.isConstInt("maxVerticesOut"))
-                                {
-                                    progMaxVerticesOut = shaderline.getValueInt();
+                                    if (shaderline.isConstInt("maxVerticesOut"))
+                                    {
+                                        progMaxVerticesOut = shaderline.getValueInt();
+                                    }
                                 }
                             }
                         }
                     }
+                    catch (Exception exception)
+                    {
+                        SMCLog.severe("Couldn't read " + filename + "!");
+                        exception.printStackTrace();
+                        ARBShaderObjects.glDeleteObjectARB(i);
+                        return 0;
+                    }
                 }
-                catch (Exception exception1)
+
+                String s2 = linebuffer.toString();
+
+                if (saveFinalShaders)
                 {
-                    SMCLog.severe("Couldn't read " + filename + "!");
-                    exception1.printStackTrace();
-                    ARBShaderObjects.glDeleteObjectARB(i);
-                    return 0;
+                    saveShader(filename, s2);
                 }
-            }
 
-            if (saveFinalShaders)
-            {
-                saveShader(filename, stringbuilder.toString());
-            }
+                ARBShaderObjects.glShaderSourceARB(i, (CharSequence)s2);
+                ARBShaderObjects.glCompileShaderARB(i);
 
-            ARBShaderObjects.glShaderSourceARB(i, (CharSequence)stringbuilder);
-            ARBShaderObjects.glCompileShaderARB(i);
+                if (GL43.glGetShaderi(i, 35713) != 1)
+                {
+                    SMCLog.severe("Error compiling geometry shader: " + filename);
+                }
 
-            if (GL32.glGetShaderi(i, 35713) != 1)
-            {
-                SMCLog.severe("Error compiling geometry shader: " + filename);
+                printShaderLogInfo(i, filename, list);
+                return i;
             }
-
-            printShaderLogInfo(i, filename, list);
-            return i;
         }
     }
 
     private static int createFragShader(Program program, String filename)
     {
-        int i = ARBShaderObjects.glCreateShaderObjectARB(ARBFragmentShader.GL_FRAGMENT_SHADER_ARB);
+        InputStream inputstream = shaderPack.getResourceAsStream(filename);
 
-        if (i == 0)
+        if (inputstream == null)
         {
             return 0;
         }
         else
         {
-            StringBuilder stringbuilder = new StringBuilder(131072);
-            BufferedReader bufferedreader = null;
+            int i = ARBShaderObjects.glCreateShaderObjectARB(ARBFragmentShader.GL_FRAGMENT_SHADER_ARB);
 
-            try
-            {
-                bufferedreader = new BufferedReader(getShaderReader(filename));
-            }
-            catch (Exception exception)
+            if (i == 0)
             {
-                ARBShaderObjects.glDeleteObjectARB(i);
                 return 0;
             }
-
-            ShaderOption[] ashaderoption = getChangedOptions(shaderPackOptions);
-            List<String> list = new ArrayList<>();
-
-            if (bufferedreader != null)
+            else
             {
-                try
-                {
-                    bufferedreader = ShaderPackParser.resolveIncludes(bufferedreader, filename, shaderPack, 0, list, 0);
-                    MacroState macrostate = new MacroState();
+                ShaderOption[] ashaderoption = getChangedOptions(shaderPackOptions);
+                List<String> list = new ArrayList<>();
+                LineBuffer linebuffer = new LineBuffer();
 
-                    while (true)
+                if (linebuffer != null)
+                {
+                    try
                     {
-                        String s = bufferedreader.readLine();
+                        LineBuffer linebuffer1 = LineBuffer.readAll(new InputStreamReader(inputstream));
+                        linebuffer1 = ShaderPackParser.resolveIncludes(linebuffer1, filename, shaderPack, 0, list, 0);
+                        MacroState macrostate = new MacroState();
 
-                        if (s == null)
+                        for (String s : linebuffer1)
                         {
-                            bufferedreader.close();
-                            break;
-                        }
-
-                        s = applyOptions(s, ashaderoption);
-                        stringbuilder.append(s).append('\n');
-
-                        if (macrostate.processLine(s))
-                        {
-                            ShaderLine shaderline = ShaderParser.parseLine(s);
+                            s = applyOptions(s, ashaderoption);
+                            linebuffer.add(s);
 
-                            if (shaderline != null)
+                            if (macrostate.processLine(s))
                             {
-                                if (shaderline.isUniform())
-                                {
-                                    String s6 = shaderline.getName();
-                                    int l1;
+                                ShaderLine shaderline = ShaderParser.parseLine(s);
 
-                                    if ((l1 = ShaderParser.getShadowDepthIndex(s6)) >= 0)
-                                    {
-                                        usedShadowDepthBuffers = Math.max(usedShadowDepthBuffers, l1 + 1);
-                                    }
-                                    else if ((l1 = ShaderParser.getShadowColorIndex(s6)) >= 0)
-                                    {
-                                        usedShadowColorBuffers = Math.max(usedShadowColorBuffers, l1 + 1);
-                                    }
-                                    else if ((l1 = ShaderParser.getDepthIndex(s6)) >= 0)
-                                    {
-                                        usedDepthBuffers = Math.max(usedDepthBuffers, l1 + 1);
-                                    }
-                                    else if (s6.equals("gdepth") && gbuffersFormat[1] == 6408)
-                                    {
-                                        gbuffersFormat[1] = 34836;
-                                    }
-                                    else if ((l1 = ShaderParser.getColorIndex(s6)) >= 0)
-                                    {
-                                        usedColorBuffers = Math.max(usedColorBuffers, l1 + 1);
-                                    }
-                                    else if (s6.equals("centerDepthSmooth"))
+                                if (shaderline != null)
+                                {
+                                    if (shaderline.isUniform())
                                     {
-                                        centerDepthSmoothEnabled = true;
+                                        String s9 = shaderline.getName();
+                                        int l1;
+
+                                        if ((l1 = ShaderParser.getShadowDepthIndex(s9)) >= 0)
+                                        {
+                                            usedShadowDepthBuffers = Math.max(usedShadowDepthBuffers, l1 + 1);
+                                        }
+                                        else if ((l1 = ShaderParser.getShadowColorIndex(s9)) >= 0)
+                                        {
+                                            usedShadowColorBuffers = Math.max(usedShadowColorBuffers, l1 + 1);
+                                        }
+                                        else if ((l1 = ShaderParser.getShadowColorImageIndex(s9)) >= 0)
+                                        {
+                                            usedShadowColorBuffers = Math.max(usedShadowColorBuffers, l1 + 1);
+                                            bindImageTextures = true;
+                                        }
+                                        else if ((l1 = ShaderParser.getDepthIndex(s9)) >= 0)
+                                        {
+                                            usedDepthBuffers = Math.max(usedDepthBuffers, l1 + 1);
+                                        }
+                                        else if (s9.equals("gdepth") && gbuffersFormat[1] == 6408)
+                                        {
+                                            gbuffersFormat[1] = 34836;
+                                        }
+                                        else if ((l1 = ShaderParser.getColorIndex(s9)) >= 0)
+                                        {
+                                            usedColorBuffers = Math.max(usedColorBuffers, l1 + 1);
+                                        }
+                                        else if ((l1 = ShaderParser.getColorImageIndex(s9)) >= 0)
+                                        {
+                                            usedColorBuffers = Math.max(usedColorBuffers, l1 + 1);
+                                            bindImageTextures = true;
+                                        }
+                                        else if (s9.equals("centerDepthSmooth"))
+                                        {
+                                            centerDepthSmoothEnabled = true;
+                                        }
                                     }
-                                }
-                                else if (!shaderline.isConstInt("shadowMapResolution") && !shaderline.isProperty("SHADOWRES"))
-                                {
-                                    if (!shaderline.isConstFloat("shadowMapFov") && !shaderline.isProperty("SHADOWFOV"))
+                                    else if (!shaderline.isConstInt("shadowMapResolution") && !shaderline.isProperty("SHADOWRES"))
                                     {
-                                        if (!shaderline.isConstFloat("shadowDistance") && !shaderline.isProperty("SHADOWHPL"))
+                                        if (!shaderline.isConstFloat("shadowMapFov") && !shaderline.isProperty("SHADOWFOV"))
                                         {
-                                            if (shaderline.isConstFloat("shadowDistanceRenderMul"))
-                                            {
-                                                shadowDistanceRenderMul = shaderline.getValueFloat();
-                                                SMCLog.info("Shadow distance render mul: " + shadowDistanceRenderMul);
-                                            }
-                                            else if (shaderline.isConstFloat("shadowIntervalSize"))
-                                            {
-                                                shadowIntervalSize = shaderline.getValueFloat();
-                                                SMCLog.info("Shadow map interval size: " + shadowIntervalSize);
-                                            }
-                                            else if (shaderline.isConstBool("generateShadowMipmap", true))
-                                            {
-                                                Arrays.fill(shadowMipmapEnabled, true);
-                                                SMCLog.info("Generate shadow mipmap");
-                                            }
-                                            else if (shaderline.isConstBool("generateShadowColorMipmap", true))
+                                            if (!shaderline.isConstFloat("shadowDistance") && !shaderline.isProperty("SHADOWHPL"))
                                             {
-                                                Arrays.fill(shadowColorMipmapEnabled, true);
-                                                SMCLog.info("Generate shadow color mipmap");
-                                            }
-                                            else if (shaderline.isConstBool("shadowHardwareFiltering", true))
-                                            {
-                                                Arrays.fill(shadowHardwareFilteringEnabled, true);
-                                                SMCLog.info("Hardware shadow filtering enabled.");
-                                            }
-                                            else if (shaderline.isConstBool("shadowHardwareFiltering0", true))
-                                            {
-                                                shadowHardwareFilteringEnabled[0] = true;
-                                                SMCLog.info("shadowHardwareFiltering0");
-                                            }
-                                            else if (shaderline.isConstBool("shadowHardwareFiltering1", true))
-                                            {
-                                                shadowHardwareFilteringEnabled[1] = true;
-                                                SMCLog.info("shadowHardwareFiltering1");
-                                            }
-                                            else if (shaderline.isConstBool("shadowtex0Mipmap", "shadowtexMipmap", true))
-                                            {
-                                                shadowMipmapEnabled[0] = true;
-                                                SMCLog.info("shadowtex0Mipmap");
-                                            }
-                                            else if (shaderline.isConstBool("shadowtex1Mipmap", true))
-                                            {
-                                                shadowMipmapEnabled[1] = true;
-                                                SMCLog.info("shadowtex1Mipmap");
-                                            }
-                                            else if (shaderline.isConstBool("shadowcolor0Mipmap", "shadowColor0Mipmap", true))
-                                            {
-                                                shadowColorMipmapEnabled[0] = true;
-                                                SMCLog.info("shadowcolor0Mipmap");
-                                            }
-                                            else if (shaderline.isConstBool("shadowcolor1Mipmap", "shadowColor1Mipmap", true))
-                                            {
-                                                shadowColorMipmapEnabled[1] = true;
-                                                SMCLog.info("shadowcolor1Mipmap");
-                                            }
-                                            else if (shaderline.isConstBool("shadowtex0Nearest", "shadowtexNearest", "shadow0MinMagNearest", true))
-                                            {
-                                                shadowFilterNearest[0] = true;
-                                                SMCLog.info("shadowtex0Nearest");
-                                            }
-                                            else if (shaderline.isConstBool("shadowtex1Nearest", "shadow1MinMagNearest", true))
-                                            {
-                                                shadowFilterNearest[1] = true;
-                                                SMCLog.info("shadowtex1Nearest");
-                                            }
-                                            else if (shaderline.isConstBool("shadowcolor0Nearest", "shadowColor0Nearest", "shadowColor0MinMagNearest", true))
-                                            {
-                                                shadowColorFilterNearest[0] = true;
-                                                SMCLog.info("shadowcolor0Nearest");
-                                            }
-                                            else if (shaderline.isConstBool("shadowcolor1Nearest", "shadowColor1Nearest", "shadowColor1MinMagNearest", true))
-                                            {
-                                                shadowColorFilterNearest[1] = true;
-                                                SMCLog.info("shadowcolor1Nearest");
-                                            }
-                                            else if (!shaderline.isConstFloat("wetnessHalflife") && !shaderline.isProperty("WETNESSHL"))
-                                            {
-                                                if (!shaderline.isConstFloat("drynessHalflife") && !shaderline.isProperty("DRYNESSHL"))
+                                                if (shaderline.isConstFloat("shadowDistanceRenderMul"))
                                                 {
-                                                    if (shaderline.isConstFloat("eyeBrightnessHalflife"))
-                                                    {
-                                                        eyeBrightnessHalflife = shaderline.getValueFloat();
-                                                        SMCLog.info("Eye brightness halflife: " + eyeBrightnessHalflife);
-                                                    }
-                                                    else if (shaderline.isConstFloat("centerDepthHalflife"))
-                                                    {
-                                                        centerDepthSmoothHalflife = shaderline.getValueFloat();
-                                                        SMCLog.info("Center depth halflife: " + centerDepthSmoothHalflife);
-                                                    }
-                                                    else if (shaderline.isConstFloat("sunPathRotation"))
-                                                    {
-                                                        sunPathRotation = shaderline.getValueFloat();
-                                                        SMCLog.info("Sun path rotation: " + sunPathRotation);
-                                                    }
-                                                    else if (shaderline.isConstFloat("ambientOcclusionLevel"))
-                                                    {
-                                                        aoLevel = Config.limit(shaderline.getValueFloat(), 0.0F, 1.0F);
-                                                        SMCLog.info("AO Level: " + aoLevel);
-                                                    }
-                                                    else if (shaderline.isConstInt("superSamplingLevel"))
+                                                    shadowDistanceRenderMul = shaderline.getValueFloat();
+                                                    SMCLog.info("Shadow distance render mul: " + shadowDistanceRenderMul);
+                                                }
+                                                else if (shaderline.isConstFloat("shadowIntervalSize"))
+                                                {
+                                                    shadowIntervalSize = shaderline.getValueFloat();
+                                                    SMCLog.info("Shadow map interval size: " + shadowIntervalSize);
+                                                }
+                                                else if (shaderline.isConstBool("generateShadowMipmap", true))
+                                                {
+                                                    Arrays.fill(shadowMipmapEnabled, true);
+                                                    SMCLog.info("Generate shadow mipmap");
+                                                }
+                                                else if (shaderline.isConstBool("generateShadowColorMipmap", true))
+                                                {
+                                                    Arrays.fill(shadowColorMipmapEnabled, true);
+                                                    SMCLog.info("Generate shadow color mipmap");
+                                                }
+                                                else if (shaderline.isConstBool("shadowHardwareFiltering", true))
+                                                {
+                                                    Arrays.fill(shadowHardwareFilteringEnabled, true);
+                                                    SMCLog.info("Hardware shadow filtering enabled.");
+                                                }
+                                                else if (shaderline.isConstBool("shadowHardwareFiltering0", true))
+                                                {
+                                                    shadowHardwareFilteringEnabled[0] = true;
+                                                    SMCLog.info("shadowHardwareFiltering0");
+                                                }
+                                                else if (shaderline.isConstBool("shadowHardwareFiltering1", true))
+                                                {
+                                                    shadowHardwareFilteringEnabled[1] = true;
+                                                    SMCLog.info("shadowHardwareFiltering1");
+                                                }
+                                                else if (shaderline.isConstBool("shadowtex0Mipmap", "shadowtexMipmap", true))
+                                                {
+                                                    shadowMipmapEnabled[0] = true;
+                                                    SMCLog.info("shadowtex0Mipmap");
+                                                }
+                                                else if (shaderline.isConstBool("shadowtex1Mipmap", true))
+                                                {
+                                                    shadowMipmapEnabled[1] = true;
+                                                    SMCLog.info("shadowtex1Mipmap");
+                                                }
+                                                else if (shaderline.isConstBool("shadowcolor0Mipmap", "shadowColor0Mipmap", true))
+                                                {
+                                                    shadowColorMipmapEnabled[0] = true;
+                                                    SMCLog.info("shadowcolor0Mipmap");
+                                                }
+                                                else if (shaderline.isConstBool("shadowcolor1Mipmap", "shadowColor1Mipmap", true))
+                                                {
+                                                    shadowColorMipmapEnabled[1] = true;
+                                                    SMCLog.info("shadowcolor1Mipmap");
+                                                }
+                                                else if (shaderline.isConstBool("shadowtex0Nearest", "shadowtexNearest", "shadow0MinMagNearest", true))
+                                                {
+                                                    shadowFilterNearest[0] = true;
+                                                    SMCLog.info("shadowtex0Nearest");
+                                                }
+                                                else if (shaderline.isConstBool("shadowtex1Nearest", "shadow1MinMagNearest", true))
+                                                {
+                                                    shadowFilterNearest[1] = true;
+                                                    SMCLog.info("shadowtex1Nearest");
+                                                }
+                                                else if (shaderline.isConstBool("shadowcolor0Nearest", "shadowColor0Nearest", "shadowColor0MinMagNearest", true))
+                                                {
+                                                    shadowColorFilterNearest[0] = true;
+                                                    SMCLog.info("shadowcolor0Nearest");
+                                                }
+                                                else if (shaderline.isConstBool("shadowcolor1Nearest", "shadowColor1Nearest", "shadowColor1MinMagNearest", true))
+                                                {
+                                                    shadowColorFilterNearest[1] = true;
+                                                    SMCLog.info("shadowcolor1Nearest");
+                                                }
+                                                else if (!shaderline.isConstFloat("wetnessHalflife") && !shaderline.isProperty("WETNESSHL"))
+                                                {
+                                                    if (!shaderline.isConstFloat("drynessHalflife") && !shaderline.isProperty("DRYNESSHL"))
                                                     {
-                                                        int i1 = shaderline.getValueInt();
-
-                                                        if (i1 > 1)
+                                                        if (shaderline.isConstFloat("eyeBrightnessHalflife"))
                                                         {
-                                                            SMCLog.info("Super sampling level: " + i1 + "x");
-                                                            superSamplingLevel = i1;
+                                                            eyeBrightnessHalflife = shaderline.getValueFloat();
+                                                            SMCLog.info("Eye brightness halflife: " + eyeBrightnessHalflife);
                                                         }
-                                                        else
+                                                        else if (shaderline.isConstFloat("centerDepthHalflife"))
                                                         {
-                                                            superSamplingLevel = 1;
+                                                            centerDepthSmoothHalflife = shaderline.getValueFloat();
+                                                            SMCLog.info("Center depth halflife: " + centerDepthSmoothHalflife);
                                                         }
-                                                    }
-                                                    else if (shaderline.isConstInt("noiseTextureResolution"))
-                                                    {
-                                                        noiseTextureResolution = shaderline.getValueInt();
-                                                        noiseTextureEnabled = true;
-                                                        SMCLog.info("Noise texture enabled");
-                                                        SMCLog.info("Noise texture resolution: " + noiseTextureResolution);
-                                                    }
-                                                    else if (shaderline.isConstIntSuffix("Format"))
-                                                    {
-                                                        String s5 = StrUtils.removeSuffix(shaderline.getName(), "Format");
-                                                        String s7 = shaderline.getValue();
-                                                        int i2 = getBufferIndexFromString(s5);
-                                                        int l = getTextureFormatFromString(s7);
+                                                        else if (shaderline.isConstFloat("sunPathRotation"))
+                                                        {
+                                                            sunPathRotation = shaderline.getValueFloat();
+                                                            SMCLog.info("Sun path rotation: " + sunPathRotation);
+                                                        }
+                                                        else if (shaderline.isConstFloat("ambientOcclusionLevel"))
+                                                        {
+                                                            aoLevel = Config.limit(shaderline.getValueFloat(), 0.0F, 1.0F);
+                                                            SMCLog.info("AO Level: " + aoLevel);
+                                                        }
+                                                        else if (shaderline.isConstInt("superSamplingLevel"))
+                                                        {
+                                                            int j = shaderline.getValueInt();
 
-                                                        if (i2 >= 0 && l != 0)
+                                                            if (j > 1)
+                                                            {
+                                                                SMCLog.info("Super sampling level: " + j + "x");
+                                                                superSamplingLevel = j;
+                                                            }
+                                                            else
+                                                            {
+                                                                superSamplingLevel = 1;
+                                                            }
+                                                        }
+                                                        else if (shaderline.isConstInt("noiseTextureResolution"))
                                                         {
-                                                            gbuffersFormat[i2] = l;
-                                                            SMCLog.info("%s format: %s", s5, s7);
+                                                            noiseTextureResolution = shaderline.getValueInt();
+                                                            noiseTextureEnabled = true;
+                                                            SMCLog.info("Noise texture enabled");
+                                                            SMCLog.info("Noise texture resolution: " + noiseTextureResolution);
                                                         }
-                                                    }
-                                                    else if (shaderline.isConstBoolSuffix("Clear", false))
-                                                    {
-                                                        if (ShaderParser.isComposite(filename) || ShaderParser.isDeferred(filename))
+                                                        else if (shaderline.isConstIntSuffix("Format"))
                                                         {
-                                                            String s4 = StrUtils.removeSuffix(shaderline.getName(), "Clear");
-                                                            int k1 = getBufferIndexFromString(s4);
+                                                            String s3 = StrUtils.removeSuffix(shaderline.getName(), "Format");
+                                                            String s1 = shaderline.getValue();
+                                                            int k = getTextureFormatFromString(s1);
 
-                                                            if (k1 >= 0)
+                                                            if (k != 0)
                                                             {
-                                                                gbuffersClear[k1] = false;
-                                                                SMCLog.info("%s clear disabled", s4);
+                                                                int l = getBufferIndex(s3);
+
+                                                                if (l >= 0)
+                                                                {
+                                                                    gbuffersFormat[l] = k;
+                                                                    SMCLog.info("%s format: %s", s3, s1);
+                                                                }
+
+                                                                int i1 = ShaderParser.getShadowColorIndex(s3);
+
+                                                                if (i1 >= 0)
+                                                                {
+                                                                    shadowBuffersFormat[i1] = k;
+                                                                    SMCLog.info("%s format: %s", s3, s1);
+                                                                }
                                                             }
                                                         }
-                                                    }
-                                                    else if (shaderline.isConstVec4Suffix("ClearColor"))
-                                                    {
-                                                        if (ShaderParser.isComposite(filename) || ShaderParser.isDeferred(filename))
+                                                        else if (shaderline.isConstBoolSuffix("Clear", false))
                                                         {
-                                                            String s3 = StrUtils.removeSuffix(shaderline.getName(), "ClearColor");
-                                                            int j1 = getBufferIndexFromString(s3);
+                                                            if (program.getProgramStage().isAnyComposite())
+                                                            {
+                                                                String s4 = StrUtils.removeSuffix(shaderline.getName(), "Clear");
+                                                                int j1 = getBufferIndex(s4);
+
+                                                                if (j1 >= 0)
+                                                                {
+                                                                    gbuffersClear[j1] = false;
+                                                                    SMCLog.info("%s clear disabled", s4);
+                                                                }
 
-                                                            if (j1 >= 0)
+                                                                int i2 = ShaderParser.getShadowColorIndex(s4);
+
+                                                                if (i2 >= 0)
+                                                                {
+                                                                    shadowBuffersClear[i2] = false;
+                                                                    SMCLog.info("%s clear disabled", s4);
+                                                                }
+                                                            }
+                                                        }
+                                                        else if (shaderline.isConstVec4Suffix("ClearColor"))
+                                                        {
+                                                            if (program.getProgramStage().isAnyComposite())
                                                             {
+                                                                String s5 = StrUtils.removeSuffix(shaderline.getName(), "ClearColor");
                                                                 Vector4f vector4f = shaderline.getValueVec4();
 
                                                                 if (vector4f != null)
                                                                 {
-                                                                    gbuffersClearColor[j1] = vector4f;
-                                                                    SMCLog.info("%s clear color: %s %s %s %s", s3, vector4f.getX(), vector4f.getY(), vector4f.getZ(), vector4f.getW());
+                                                                    int j2 = getBufferIndex(s5);
+
+                                                                    if (j2 >= 0)
+                                                                    {
+                                                                        gbuffersClearColor[j2] = vector4f;
+                                                                        SMCLog.info("%s clear color: %s %s %s %s", s5, vector4f.getX(), vector4f.getY(), vector4f.getZ(), vector4f.getW());
+                                                                    }
+
+                                                                    int l2 = ShaderParser.getShadowColorIndex(s5);
+
+                                                                    if (l2 >= 0)
+                                                                    {
+                                                                        shadowBuffersClearColor[l2] = vector4f;
+                                                                        SMCLog.info("%s clear color: %s %s %s %s", s5, vector4f.getX(), vector4f.getY(), vector4f.getZ(), vector4f.getW());
+                                                                    }
                                                                 }
                                                                 else
                                                                 {
@@ -3086,118 +3660,130 @@
                                                                 }
                                                             }
                                                         }
-                                                    }
-                                                    else if (shaderline.isProperty("GAUX4FORMAT", "RGBA32F"))
-                                                    {
-                                                        gbuffersFormat[7] = 34836;
-                                                        SMCLog.info("gaux4 format : RGB32AF");
-                                                    }
-                                                    else if (shaderline.isProperty("GAUX4FORMAT", "RGB32F"))
-                                                    {
-                                                        gbuffersFormat[7] = 34837;
-                                                        SMCLog.info("gaux4 format : RGB32F");
-                                                    }
-                                                    else if (shaderline.isProperty("GAUX4FORMAT", "RGB16"))
-                                                    {
-                                                        gbuffersFormat[7] = 32852;
-                                                        SMCLog.info("gaux4 format : RGB16");
-                                                    }
-                                                    else if (shaderline.isConstBoolSuffix("MipmapEnabled", true))
-                                                    {
-                                                        if (ShaderParser.isComposite(filename) || ShaderParser.isDeferred(filename) || ShaderParser.isFinal(filename))
+                                                        else if (shaderline.isProperty("GAUX4FORMAT", "RGBA32F"))
                                                         {
-                                                            String s2 = StrUtils.removeSuffix(shaderline.getName(), "MipmapEnabled");
-                                                            int j = getBufferIndexFromString(s2);
-
-                                                            if (j >= 0)
+                                                            gbuffersFormat[7] = 34836;
+                                                            SMCLog.info("gaux4 format : RGB32AF");
+                                                        }
+                                                        else if (shaderline.isProperty("GAUX4FORMAT", "RGB32F"))
+                                                        {
+                                                            gbuffersFormat[7] = 34837;
+                                                            SMCLog.info("gaux4 format : RGB32F");
+                                                        }
+                                                        else if (shaderline.isProperty("GAUX4FORMAT", "RGB16"))
+                                                        {
+                                                            gbuffersFormat[7] = 32852;
+                                                            SMCLog.info("gaux4 format : RGB16");
+                                                        }
+                                                        else if (shaderline.isConstBoolSuffix("MipmapEnabled", true))
+                                                        {
+                                                            if (program.getProgramStage().isAnyComposite())
                                                             {
-                                                                int k = program.getCompositeMipmapSetting();
-                                                                k = k | 1 << j;
-                                                                program.setCompositeMipmapSetting(k);
-                                                                SMCLog.info("%s mipmap enabled", s2);
+                                                                String s6 = StrUtils.removeSuffix(shaderline.getName(), "MipmapEnabled");
+                                                                int k1 = getBufferIndex(s6);
+
+                                                                if (k1 >= 0)
+                                                                {
+                                                                    int k2 = program.getCompositeMipmapSetting();
+                                                                    k2 = k2 | 1 << k1;
+                                                                    program.setCompositeMipmapSetting(k2);
+                                                                    SMCLog.info("%s mipmap enabled", s6);
+                                                                }
                                                             }
                                                         }
-                                                    }
-                                                    else if (shaderline.isProperty("DRAWBUFFERS"))
-                                                    {
-                                                        String s1 = shaderline.getValue();
-
-                                                        if (ShaderParser.isValidDrawBuffers(s1))
+                                                        else if (shaderline.isProperty("DRAWBUFFERS"))
                                                         {
-                                                            program.setDrawBufSettings(s1);
+                                                            String s7 = shaderline.getValue();
+                                                            String[] astring = ShaderParser.parseDrawBuffers(s7);
+
+                                                            if (astring != null)
+                                                            {
+                                                                program.setDrawBufSettings(astring);
+                                                            }
+                                                            else
+                                                            {
+                                                                SMCLog.warning("Invalid draw buffers: " + s7);
+                                                            }
                                                         }
-                                                        else
+                                                        else if (shaderline.isProperty("RENDERTARGETS"))
                                                         {
-                                                            SMCLog.warning("Invalid draw buffers: " + s1);
+                                                            String s8 = shaderline.getValue();
+                                                            String[] astring1 = ShaderParser.parseRenderTargets(s8);
+
+                                                            if (astring1 != null)
+                                                            {
+                                                                program.setDrawBufSettings(astring1);
+                                                            }
+                                                            else
+                                                            {
+                                                                SMCLog.warning("Invalid render targets: " + s8);
+                                                            }
                                                         }
                                                     }
+                                                    else
+                                                    {
+                                                        drynessHalfLife = shaderline.getValueFloat();
+                                                        SMCLog.info("Dryness halflife: " + drynessHalfLife);
+                                                    }
                                                 }
                                                 else
                                                 {
-                                                    drynessHalfLife = shaderline.getValueFloat();
-                                                    SMCLog.info("Dryness halflife: " + drynessHalfLife);
+                                                    wetnessHalfLife = shaderline.getValueFloat();
+                                                    SMCLog.info("Wetness halflife: " + wetnessHalfLife);
                                                 }
                                             }
                                             else
                                             {
-                                                wetnessHalfLife = shaderline.getValueFloat();
-                                                SMCLog.info("Wetness halflife: " + wetnessHalfLife);
+                                                shadowMapHalfPlane = shaderline.getValueFloat();
+                                                shadowMapIsOrtho = true;
+                                                SMCLog.info("Shadow map distance: " + shadowMapHalfPlane);
                                             }
                                         }
                                         else
                                         {
-                                            shadowMapHalfPlane = shaderline.getValueFloat();
-                                            shadowMapIsOrtho = true;
-                                            SMCLog.info("Shadow map distance: " + shadowMapHalfPlane);
+                                            shadowMapFOV = shaderline.getValueFloat();
+                                            shadowMapIsOrtho = false;
+                                            SMCLog.info("Shadow map field of view: " + shadowMapFOV);
                                         }
                                     }
                                     else
                                     {
-                                        shadowMapFOV = shaderline.getValueFloat();
-                                        shadowMapIsOrtho = false;
-                                        SMCLog.info("Shadow map field of view: " + shadowMapFOV);
+                                        spShadowMapWidth = spShadowMapHeight = shaderline.getValueInt();
+                                        shadowMapWidth = shadowMapHeight = Math.round((float)spShadowMapWidth * configShadowResMul);
+                                        SMCLog.info("Shadow map resolution: " + spShadowMapWidth);
                                     }
                                 }
-                                else
-                                {
-                                    spShadowMapWidth = spShadowMapHeight = shaderline.getValueInt();
-                                    shadowMapWidth = shadowMapHeight = Math.round((float)spShadowMapWidth * configShadowResMul);
-                                    SMCLog.info("Shadow map resolution: " + spShadowMapWidth);
-                                }
                             }
                         }
                     }
+                    catch (Exception exception)
+                    {
+                        SMCLog.severe("Couldn't read " + filename + "!");
+                        exception.printStackTrace();
+                        ARBShaderObjects.glDeleteObjectARB(i);
+                        return 0;
+                    }
                 }
-                catch (Exception exception1)
+
+                String s2 = linebuffer.toString();
+
+                if (saveFinalShaders)
                 {
-                    SMCLog.severe("Couldn't read " + filename + "!");
-                    exception1.printStackTrace();
-                    ARBShaderObjects.glDeleteObjectARB(i);
-                    return 0;
+                    saveShader(filename, s2);
                 }
-            }
 
-            if (saveFinalShaders)
-            {
-                saveShader(filename, stringbuilder.toString());
-            }
+                ARBShaderObjects.glShaderSourceARB(i, (CharSequence)s2);
+                ARBShaderObjects.glCompileShaderARB(i);
 
-            ARBShaderObjects.glShaderSourceARB(i, (CharSequence)stringbuilder);
-            ARBShaderObjects.glCompileShaderARB(i);
+                if (GL43.glGetShaderi(i, 35713) != 1)
+                {
+                    SMCLog.severe("Error compiling fragment shader: " + filename);
+                }
 
-            if (GL32.glGetShaderi(i, 35713) != 1)
-            {
-                SMCLog.severe("Error compiling fragment shader: " + filename);
+                printShaderLogInfo(i, filename, list);
+                return i;
             }
-
-            printShaderLogInfo(i, filename, list);
-            return i;
-        }
-    }
-
-    private static Reader getShaderReader(String filename)
-    {
-        return new InputStreamReader(shaderPack.getResourceAsStream(filename));
+        }
     }
 
     public static void saveShader(String filename, String code)
@@ -3274,7 +3860,7 @@
     private static boolean printShaderLogInfo(int shader, String name, List<String> listFiles)
     {
         IntBuffer intbuffer = BufferUtils.createIntBuffer(1);
-        int i = GL32.glGetShaderi(shader, 35716);
+        int i = GL43.glGetShaderi(shader, 35716);
 
         if (i <= 1)
         {
@@ -3288,28 +3874,13 @@
                 SMCLog.info("File: " + (j + 1) + " = " + s);
             }
 
-            String s1 = GL32.glGetShaderInfoLog(shader, i);
+            String s1 = GL43.glGetShaderInfoLog(shader, i);
             s1 = StrUtils.trim(s1, " \n\r\t");
             SMCLog.info("Shader info log: " + name + "\n" + s1);
             return false;
         }
     }
 
-    public static void setDrawBuffers(IntBuffer drawBuffers)
-    {
-        if (drawBuffers == null)
-        {
-            drawBuffers = drawBuffersNone;
-        }
-
-        if (activeDrawBuffers != drawBuffers)
-        {
-            activeDrawBuffers = drawBuffers;
-            GL32.glDrawBuffers(drawBuffers);
-            checkGLError("setDrawBuffers");
-        }
-    }
-
     public static void useProgram(Program program)
     {
         checkGLError("pre-useProgram");
@@ -3327,7 +3898,20 @@
         {
             flushRenderBuffers();
             updateAlphaBlend(activeProgram, program);
+
+            if (glDebugGroups && glDebugGroupProgram)
+            {
+                KHRDebug.glPopDebugGroup();
+            }
+
             activeProgram = program;
+
+            if (glDebugGroups)
+            {
+                KHRDebug.glPushDebugGroup(33354, 0, activeProgram.getRealProgramName());
+                glDebugGroupProgram = true;
+            }
+
             int i = program.getId();
             activeProgramID = i;
             ARBShaderObjects.glUseProgramObjectARB(i);
@@ -3349,209 +3933,283 @@
 
             if (i != 0)
             {
-                IntBuffer intbuffer = program.getDrawBuffers();
+                DrawBuffers drawbuffers = program.getDrawBuffers();
 
                 if (isRenderingDfb)
                 {
-                    setDrawBuffers(intbuffer);
+                    GlState.setDrawBuffers(drawbuffers);
                 }
 
-                activeCompositeMipmapSetting = program.getCompositeMipmapSetting();
-
-                switch (program.getProgramStage())
-                {
-                    case GBUFFERS:
-                        setProgramUniform1i(uniform_texture, 0);
-                        setProgramUniform1i(uniform_lightmap, 2);
-                        setProgramUniform1i(uniform_normals, 1);
-                        setProgramUniform1i(uniform_specular, 3);
-                        setProgramUniform1i(uniform_shadow, waterShadowEnabled ? 5 : 4);
-                        setProgramUniform1i(uniform_watershadow, 4);
-                        setProgramUniform1i(uniform_shadowtex0, 4);
-                        setProgramUniform1i(uniform_shadowtex1, 5);
-                        setProgramUniform1i(uniform_depthtex0, 6);
+                setProgramUniforms(program.getProgramStage());
+                setImageUniforms();
+                checkGLError("end useProgram");
+            }
+        }
+    }
 
-                        if (customTexturesGbuffers != null || hasDeferredPrograms)
-                        {
-                            setProgramUniform1i(uniform_gaux1, 7);
-                            setProgramUniform1i(uniform_gaux2, 8);
-                            setProgramUniform1i(uniform_gaux3, 9);
-                            setProgramUniform1i(uniform_gaux4, 10);
-                        }
+    private static void setProgramUniforms(ProgramStage programStage)
+    {
+        switch (programStage)
+        {
+            case GBUFFERS:
+                setProgramUniform1i(uniform_texture, 0);
+                setProgramUniform1i(uniform_lightmap, 2);
+                setProgramUniform1i(uniform_normals, 1);
+                setProgramUniform1i(uniform_specular, 3);
+                setProgramUniform1i(uniform_shadow, waterShadowEnabled ? 5 : 4);
+                setProgramUniform1i(uniform_watershadow, 4);
+                setProgramUniform1i(uniform_shadowtex0, 4);
+                setProgramUniform1i(uniform_shadowtex1, 5);
+                setProgramUniform1i(uniform_depthtex0, 6);
+
+                if (customTexturesGbuffers != null || hasDeferredPrograms)
+                {
+                    setProgramUniform1i(uniform_gaux1, 7);
+                    setProgramUniform1i(uniform_gaux2, 8);
+                    setProgramUniform1i(uniform_gaux3, 9);
+                    setProgramUniform1i(uniform_gaux4, 10);
+                    setProgramUniform1i(uniform_colortex4, 7);
+                    setProgramUniform1i(uniform_colortex5, 8);
+                    setProgramUniform1i(uniform_colortex6, 9);
+                    setProgramUniform1i(uniform_colortex7, 10);
 
-                        setProgramUniform1i(uniform_depthtex1, 11);
-                        setProgramUniform1i(uniform_shadowcolor, 13);
-                        setProgramUniform1i(uniform_shadowcolor0, 13);
-                        setProgramUniform1i(uniform_shadowcolor1, 14);
-                        setProgramUniform1i(uniform_noisetex, 15);
-                        break;
+                    if (usedColorBuffers > 8)
+                    {
+                        setProgramUniform1i(uniform_colortex8, 16);
+                        setProgramUniform1i(uniform_colortex9, 17);
+                        setProgramUniform1i(uniform_colortex10, 18);
+                        setProgramUniform1i(uniform_colortex11, 19);
+                        setProgramUniform1i(uniform_colortex12, 20);
+                        setProgramUniform1i(uniform_colortex13, 21);
+                        setProgramUniform1i(uniform_colortex14, 22);
+                        setProgramUniform1i(uniform_colortex15, 23);
+                    }
+                }
 
-                    case DEFERRED:
-                    case COMPOSITE:
-                        setProgramUniform1i(uniform_gcolor, 0);
-                        setProgramUniform1i(uniform_gdepth, 1);
-                        setProgramUniform1i(uniform_gnormal, 2);
-                        setProgramUniform1i(uniform_composite, 3);
-                        setProgramUniform1i(uniform_gaux1, 7);
-                        setProgramUniform1i(uniform_gaux2, 8);
-                        setProgramUniform1i(uniform_gaux3, 9);
-                        setProgramUniform1i(uniform_gaux4, 10);
-                        setProgramUniform1i(uniform_colortex0, 0);
-                        setProgramUniform1i(uniform_colortex1, 1);
-                        setProgramUniform1i(uniform_colortex2, 2);
-                        setProgramUniform1i(uniform_colortex3, 3);
-                        setProgramUniform1i(uniform_colortex4, 7);
-                        setProgramUniform1i(uniform_colortex5, 8);
-                        setProgramUniform1i(uniform_colortex6, 9);
-                        setProgramUniform1i(uniform_colortex7, 10);
-                        setProgramUniform1i(uniform_shadow, waterShadowEnabled ? 5 : 4);
-                        setProgramUniform1i(uniform_watershadow, 4);
-                        setProgramUniform1i(uniform_shadowtex0, 4);
-                        setProgramUniform1i(uniform_shadowtex1, 5);
-                        setProgramUniform1i(uniform_gdepthtex, 6);
-                        setProgramUniform1i(uniform_depthtex0, 6);
-                        setProgramUniform1i(uniform_depthtex1, 11);
-                        setProgramUniform1i(uniform_depthtex2, 12);
-                        setProgramUniform1i(uniform_shadowcolor, 13);
-                        setProgramUniform1i(uniform_shadowcolor0, 13);
-                        setProgramUniform1i(uniform_shadowcolor1, 14);
-                        setProgramUniform1i(uniform_noisetex, 15);
-                        break;
+                setProgramUniform1i(uniform_depthtex1, 11);
+                setProgramUniform1i(uniform_shadowcolor, 13);
+                setProgramUniform1i(uniform_shadowcolor0, 13);
+                setProgramUniform1i(uniform_shadowcolor1, 14);
+                setProgramUniform1i(uniform_noisetex, 15);
+                break;
 
-                    case SHADOW:
-                        setProgramUniform1i(uniform_tex, 0);
-                        setProgramUniform1i(uniform_texture, 0);
-                        setProgramUniform1i(uniform_lightmap, 2);
-                        setProgramUniform1i(uniform_normals, 1);
-                        setProgramUniform1i(uniform_specular, 3);
-                        setProgramUniform1i(uniform_shadow, waterShadowEnabled ? 5 : 4);
-                        setProgramUniform1i(uniform_watershadow, 4);
-                        setProgramUniform1i(uniform_shadowtex0, 4);
-                        setProgramUniform1i(uniform_shadowtex1, 5);
+            case SHADOWCOMP:
+            case PREPARE:
+            case DEFERRED:
+            case COMPOSITE:
+                setProgramUniform1i(uniform_gcolor, 0);
+                setProgramUniform1i(uniform_gdepth, 1);
+                setProgramUniform1i(uniform_gnormal, 2);
+                setProgramUniform1i(uniform_composite, 3);
+                setProgramUniform1i(uniform_gaux1, 7);
+                setProgramUniform1i(uniform_gaux2, 8);
+                setProgramUniform1i(uniform_gaux3, 9);
+                setProgramUniform1i(uniform_gaux4, 10);
+                setProgramUniform1i(uniform_colortex0, 0);
+                setProgramUniform1i(uniform_colortex1, 1);
+                setProgramUniform1i(uniform_colortex2, 2);
+                setProgramUniform1i(uniform_colortex3, 3);
+                setProgramUniform1i(uniform_colortex4, 7);
+                setProgramUniform1i(uniform_colortex5, 8);
+                setProgramUniform1i(uniform_colortex6, 9);
+                setProgramUniform1i(uniform_colortex7, 10);
+
+                if (usedColorBuffers > 8)
+                {
+                    setProgramUniform1i(uniform_colortex8, 16);
+                    setProgramUniform1i(uniform_colortex9, 17);
+                    setProgramUniform1i(uniform_colortex10, 18);
+                    setProgramUniform1i(uniform_colortex11, 19);
+                    setProgramUniform1i(uniform_colortex12, 20);
+                    setProgramUniform1i(uniform_colortex13, 21);
+                    setProgramUniform1i(uniform_colortex14, 22);
+                    setProgramUniform1i(uniform_colortex15, 23);
+                }
+
+                setProgramUniform1i(uniform_shadow, waterShadowEnabled ? 5 : 4);
+                setProgramUniform1i(uniform_watershadow, 4);
+                setProgramUniform1i(uniform_shadowtex0, 4);
+                setProgramUniform1i(uniform_shadowtex1, 5);
+                setProgramUniform1i(uniform_gdepthtex, 6);
+                setProgramUniform1i(uniform_depthtex0, 6);
+                setProgramUniform1i(uniform_depthtex1, 11);
+                setProgramUniform1i(uniform_depthtex2, 12);
+                setProgramUniform1i(uniform_shadowcolor, 13);
+                setProgramUniform1i(uniform_shadowcolor0, 13);
+                setProgramUniform1i(uniform_shadowcolor1, 14);
+                setProgramUniform1i(uniform_noisetex, 15);
+                break;
 
-                        if (customTexturesGbuffers != null)
-                        {
-                            setProgramUniform1i(uniform_gaux1, 7);
-                            setProgramUniform1i(uniform_gaux2, 8);
-                            setProgramUniform1i(uniform_gaux3, 9);
-                            setProgramUniform1i(uniform_gaux4, 10);
-                        }
+            case SHADOW:
+                setProgramUniform1i(uniform_tex, 0);
+                setProgramUniform1i(uniform_texture, 0);
+                setProgramUniform1i(uniform_lightmap, 2);
+                setProgramUniform1i(uniform_normals, 1);
+                setProgramUniform1i(uniform_specular, 3);
+                setProgramUniform1i(uniform_shadow, waterShadowEnabled ? 5 : 4);
+                setProgramUniform1i(uniform_watershadow, 4);
+                setProgramUniform1i(uniform_shadowtex0, 4);
+                setProgramUniform1i(uniform_shadowtex1, 5);
+
+                if (customTexturesGbuffers != null)
+                {
+                    setProgramUniform1i(uniform_gaux1, 7);
+                    setProgramUniform1i(uniform_gaux2, 8);
+                    setProgramUniform1i(uniform_gaux3, 9);
+                    setProgramUniform1i(uniform_gaux4, 10);
+                    setProgramUniform1i(uniform_colortex4, 7);
+                    setProgramUniform1i(uniform_colortex5, 8);
+                    setProgramUniform1i(uniform_colortex6, 9);
+                    setProgramUniform1i(uniform_colortex7, 10);
 
-                        setProgramUniform1i(uniform_shadowcolor, 13);
-                        setProgramUniform1i(uniform_shadowcolor0, 13);
-                        setProgramUniform1i(uniform_shadowcolor1, 14);
-                        setProgramUniform1i(uniform_noisetex, 15);
+                    if (usedColorBuffers > 8)
+                    {
+                        setProgramUniform1i(uniform_colortex8, 16);
+                        setProgramUniform1i(uniform_colortex9, 17);
+                        setProgramUniform1i(uniform_colortex10, 18);
+                        setProgramUniform1i(uniform_colortex11, 19);
+                        setProgramUniform1i(uniform_colortex12, 20);
+                        setProgramUniform1i(uniform_colortex13, 21);
+                        setProgramUniform1i(uniform_colortex14, 22);
+                        setProgramUniform1i(uniform_colortex15, 23);
+                    }
                 }
 
-                ItemStack itemstack = mc.player != null ? mc.player.getHeldItemMainhand() : null;
-                Item item = itemstack != null ? itemstack.getItem() : null;
-                int j = -1;
-                Block block = null;
+                setProgramUniform1i(uniform_shadowcolor, 13);
+                setProgramUniform1i(uniform_shadowcolor0, 13);
+                setProgramUniform1i(uniform_shadowcolor1, 14);
+                setProgramUniform1i(uniform_noisetex, 15);
+        }
 
-                if (item != null)
-                {
-                    j = Registry.ITEM.getId(item);
+        ItemStack itemstack = mc.player != null ? mc.player.getHeldItemMainhand() : null;
+        Item item = itemstack != null ? itemstack.getItem() : null;
+        int i = -1;
+        Block block = null;
 
-                    if (item instanceof BlockItem)
-                    {
-                        block = ((BlockItem)item).getBlock();
-                    }
+        if (item != null)
+        {
+            i = Registry.ITEM.getId(item);
 
-                    j = ItemAliases.getItemAliasId(j);
-                }
+            if (item instanceof BlockItem)
+            {
+                block = ((BlockItem)item).getBlock();
+            }
 
-                int k = block != null ? block.getDefaultState().getLightValue() : 0;
-                ItemStack itemstack1 = mc.player != null ? mc.player.getHeldItemOffhand() : null;
-                Item item1 = itemstack1 != null ? itemstack1.getItem() : null;
-                int l = -1;
-                Block block1 = null;
+            i = ItemAliases.getItemAliasId(i);
+        }
 
-                if (item1 != null)
-                {
-                    l = Registry.ITEM.getId(item1);
+        int j = block != null ? block.getDefaultState().getLightValue() : 0;
+        ItemStack itemstack1 = mc.player != null ? mc.player.getHeldItemOffhand() : null;
+        Item item1 = itemstack1 != null ? itemstack1.getItem() : null;
+        int k = -1;
+        Block block1 = null;
 
-                    if (item1 instanceof BlockItem)
-                    {
-                        block1 = ((BlockItem)item1).getBlock();
-                    }
+        if (item1 != null)
+        {
+            k = Registry.ITEM.getId(item1);
 
-                    l = ItemAliases.getItemAliasId(l);
-                }
+            if (item1 instanceof BlockItem)
+            {
+                block1 = ((BlockItem)item1).getBlock();
+            }
 
-                int i1 = block1 != null ? block1.getDefaultState().getLightValue() : 0;
+            k = ItemAliases.getItemAliasId(k);
+        }
 
-                if (isOldHandLight() && i1 > k)
-                {
-                    j = l;
-                    k = i1;
-                }
-
-                float f = mc.player != null ? mc.player.getDarknessAmbience() : 0.0F;
-                setProgramUniform1i(uniform_heldItemId, j);
-                setProgramUniform1i(uniform_heldBlockLightValue, k);
-                setProgramUniform1i(uniform_heldItemId2, l);
-                setProgramUniform1i(uniform_heldBlockLightValue2, i1);
-                setProgramUniform1i(uniform_fogMode, fogEnabled ? fogMode : 0);
-                setProgramUniform1f(uniform_fogDensity, fogEnabled ? fogDensity : 0.0F);
-                setProgramUniform3f(uniform_fogColor, fogColorR, fogColorG, fogColorB);
-                setProgramUniform3f(uniform_skyColor, skyColorR, skyColorG, skyColorB);
-                setProgramUniform1i(uniform_worldTime, (int)(worldTime % 24000L));
-                setProgramUniform1i(uniform_worldDay, (int)(worldTime / 24000L));
-                setProgramUniform1i(uniform_moonPhase, moonPhase);
-                setProgramUniform1i(uniform_frameCounter, frameCounter);
-                setProgramUniform1f(uniform_frameTime, frameTime);
-                setProgramUniform1f(uniform_frameTimeCounter, frameTimeCounter);
-                setProgramUniform1f(uniform_sunAngle, sunAngle);
-                setProgramUniform1f(uniform_shadowAngle, shadowAngle);
-                setProgramUniform1f(uniform_rainStrength, rainStrength);
-                setProgramUniform1f(uniform_aspectRatio, (float)renderWidth / (float)renderHeight);
-                setProgramUniform1f(uniform_viewWidth, (float)renderWidth);
-                setProgramUniform1f(uniform_viewHeight, (float)renderHeight);
-                setProgramUniform1f(uniform_near, 0.05F);
-                setProgramUniform1f(uniform_far, (float)(mc.gameSettings.renderDistanceChunks * 16));
-                setProgramUniform3f(uniform_sunPosition, sunPosition[0], sunPosition[1], sunPosition[2]);
-                setProgramUniform3f(uniform_moonPosition, moonPosition[0], moonPosition[1], moonPosition[2]);
-                setProgramUniform3f(uniform_shadowLightPosition, shadowLightPosition[0], shadowLightPosition[1], shadowLightPosition[2]);
-                setProgramUniform3f(uniform_upPosition, upPosition[0], upPosition[1], upPosition[2]);
-                setProgramUniform3f(uniform_previousCameraPosition, (float)previousCameraPositionX, (float)previousCameraPositionY, (float)previousCameraPositionZ);
-                setProgramUniform3f(uniform_cameraPosition, (float)cameraPositionX, (float)cameraPositionY, (float)cameraPositionZ);
-                setProgramUniformMatrix4ARB(uniform_gbufferModelView, false, modelView);
-                setProgramUniformMatrix4ARB(uniform_gbufferModelViewInverse, false, modelViewInverse);
-                setProgramUniformMatrix4ARB(uniform_gbufferPreviousProjection, false, previousProjection);
-                setProgramUniformMatrix4ARB(uniform_gbufferProjection, false, projection);
-                setProgramUniformMatrix4ARB(uniform_gbufferProjectionInverse, false, projectionInverse);
-                setProgramUniformMatrix4ARB(uniform_gbufferPreviousModelView, false, previousModelView);
-
-                if (usedShadowDepthBuffers > 0)
-                {
-                    setProgramUniformMatrix4ARB(uniform_shadowProjection, false, shadowProjection);
-                    setProgramUniformMatrix4ARB(uniform_shadowProjectionInverse, false, shadowProjectionInverse);
-                    setProgramUniformMatrix4ARB(uniform_shadowModelView, false, shadowModelView);
-                    setProgramUniformMatrix4ARB(uniform_shadowModelViewInverse, false, shadowModelViewInverse);
-                }
-
-                setProgramUniform1f(uniform_wetness, wetness);
-                setProgramUniform1f(uniform_eyeAltitude, eyePosY);
-                setProgramUniform2i(uniform_eyeBrightness, eyeBrightness & 65535, eyeBrightness >> 16);
-                setProgramUniform2i(uniform_eyeBrightnessSmooth, Math.round(eyeBrightnessFadeX), Math.round(eyeBrightnessFadeY));
-                setProgramUniform2i(uniform_terrainTextureSize, terrainTextureSize[0], terrainTextureSize[1]);
-                setProgramUniform1i(uniform_terrainIconSize, terrainIconSize);
-                setProgramUniform1i(uniform_isEyeInWater, isEyeInWater);
-                setProgramUniform1f(uniform_nightVision, nightVision);
-                setProgramUniform1f(uniform_blindness, blindness);
-                setProgramUniform1f(uniform_screenBrightness, (float)mc.gameSettings.gamma);
-                setProgramUniform1i(uniform_hideGUI, mc.gameSettings.hideGUI ? 1 : 0);
-                setProgramUniform1f(uniform_centerDepthSmooth, centerDepthSmooth);
-                setProgramUniform2i(uniform_atlasSize, atlasSizeX, atlasSizeY);
-                setProgramUniform1f(uniform_playerMood, f);
+        int l = block1 != null ? block1.getDefaultState().getLightValue() : 0;
 
-                if (customUniforms != null)
-                {
-                    customUniforms.update();
-                }
+        if (isOldHandLight() && l > j)
+        {
+            i = k;
+            j = l;
+        }
 
-                checkGLError("end useProgram");
-            }
+        float f = mc.player != null ? mc.player.getDarknessAmbience() : 0.0F;
+        setProgramUniform1i(uniform_heldItemId, i);
+        setProgramUniform1i(uniform_heldBlockLightValue, j);
+        setProgramUniform1i(uniform_heldItemId2, k);
+        setProgramUniform1i(uniform_heldBlockLightValue2, l);
+        setProgramUniform1i(uniform_fogMode, fogEnabled ? fogMode : 0);
+        setProgramUniform1f(uniform_fogDensity, fogEnabled ? fogDensity : 0.0F);
+        setProgramUniform3f(uniform_fogColor, fogColorR, fogColorG, fogColorB);
+        setProgramUniform3f(uniform_skyColor, skyColorR, skyColorG, skyColorB);
+        setProgramUniform1i(uniform_worldTime, (int)(worldTime % 24000L));
+        setProgramUniform1i(uniform_worldDay, (int)(worldTime / 24000L));
+        setProgramUniform1i(uniform_moonPhase, moonPhase);
+        setProgramUniform1i(uniform_frameCounter, frameCounter);
+        setProgramUniform1f(uniform_frameTime, frameTime);
+        setProgramUniform1f(uniform_frameTimeCounter, frameTimeCounter);
+        setProgramUniform1f(uniform_sunAngle, sunAngle);
+        setProgramUniform1f(uniform_shadowAngle, shadowAngle);
+        setProgramUniform1f(uniform_rainStrength, rainStrength);
+        setProgramUniform1f(uniform_aspectRatio, (float)renderWidth / (float)renderHeight);
+        setProgramUniform1f(uniform_viewWidth, (float)renderWidth);
+        setProgramUniform1f(uniform_viewHeight, (float)renderHeight);
+        setProgramUniform1f(uniform_near, 0.05F);
+        setProgramUniform1f(uniform_far, (float)(mc.gameSettings.renderDistanceChunks * 16));
+        //Vivecraft
+        if(Minecraft.getInstance().currentPass == RenderPass.THIRD) {
+        	setProgramUniform3f(uniform_sunPosition, sunPositionT[0], sunPositionT[1], sunPositionT[2]);
+        	setProgramUniform3f(uniform_moonPosition, moonPositionT[0], moonPositionT[1], moonPositionT[2]);
+        }else {
+        	setProgramUniform3f(uniform_sunPosition, sunPosition[0], sunPosition[1], sunPosition[2]);
+        	setProgramUniform3f(uniform_moonPosition, moonPosition[0], moonPosition[1], moonPosition[2]);
+        }
+        //
+        setProgramUniform3f(uniform_moonPosition, moonPosition[0], moonPosition[1], moonPosition[2]);
+        setProgramUniform3f(uniform_shadowLightPosition, shadowLightPosition[0], shadowLightPosition[1], shadowLightPosition[2]);
+        setProgramUniform3f(uniform_upPosition, upPosition[0], upPosition[1], upPosition[2]);
+        setProgramUniform3f(uniform_previousCameraPosition, (float)previousCameraPositionX, (float)previousCameraPositionY, (float)previousCameraPositionZ);
+        setProgramUniform3f(uniform_cameraPosition, (float)cameraPositionX, (float)cameraPositionY, (float)cameraPositionZ);
+        setProgramUniformMatrix4ARB(uniform_gbufferModelView, false, modelView);
+        setProgramUniformMatrix4ARB(uniform_gbufferModelViewInverse, false, modelViewInverse);
+        setProgramUniformMatrix4ARB(uniform_gbufferPreviousProjection, false, previousProjection);
+        setProgramUniformMatrix4ARB(uniform_gbufferProjection, false, projection);
+        setProgramUniformMatrix4ARB(uniform_gbufferProjectionInverse, false, projectionInverse);
+        setProgramUniformMatrix4ARB(uniform_gbufferPreviousModelView, false, previousModelView);
+
+        if (hasShadowMap)
+        {
+            setProgramUniformMatrix4ARB(uniform_shadowProjection, false, shadowProjection);
+            setProgramUniformMatrix4ARB(uniform_shadowProjectionInverse, false, shadowProjectionInverse);
+            setProgramUniformMatrix4ARB(uniform_shadowModelView, false, shadowModelView);
+            setProgramUniformMatrix4ARB(uniform_shadowModelViewInverse, false, shadowModelViewInverse);
+        }
+
+        setProgramUniform1f(uniform_wetness, wetness);
+        setProgramUniform1f(uniform_eyeAltitude, eyePosY);
+        setProgramUniform2i(uniform_eyeBrightness, eyeBrightness & 65535, eyeBrightness >> 16);
+        setProgramUniform2i(uniform_eyeBrightnessSmooth, Math.round(eyeBrightnessFadeX), Math.round(eyeBrightnessFadeY));
+        setProgramUniform2i(uniform_terrainTextureSize, terrainTextureSize[0], terrainTextureSize[1]);
+        setProgramUniform1i(uniform_terrainIconSize, terrainIconSize);
+        setProgramUniform1i(uniform_isEyeInWater, isEyeInWater);
+        setProgramUniform1f(uniform_nightVision, nightVision);
+        setProgramUniform1f(uniform_blindness, blindness);
+        setProgramUniform1f(uniform_screenBrightness, (float)mc.gameSettings.gamma);
+        setProgramUniform1i(uniform_hideGUI, mc.gameSettings.hideGUI ? 1 : 0);
+        setProgramUniform1f(uniform_centerDepthSmooth, centerDepthSmooth);
+        setProgramUniform2i(uniform_atlasSize, atlasSizeX, atlasSizeY);
+        setProgramUniform1f(uniform_playerMood, f);
+        setProgramUniform1i(uniform_renderStage, renderStage.ordinal());
+
+        if (customUniforms != null)
+        {
+            customUniforms.update();
+        }
+    }
+
+    private static void setImageUniforms()
+    {
+        if (bindImageTextures)
+        {
+            uniform_colorimg0.setValue(colorImageUnit[0]);
+            uniform_colorimg1.setValue(colorImageUnit[1]);
+            uniform_colorimg2.setValue(colorImageUnit[2]);
+            uniform_colorimg3.setValue(colorImageUnit[3]);
+            uniform_colorimg4.setValue(colorImageUnit[4]);
+            uniform_colorimg5.setValue(colorImageUnit[5]);
+            uniform_shadowcolorimg0.setValue(shadowColorImageUnit[0]);
+            uniform_shadowcolorimg1.setValue(shadowColorImageUnit[1]);
         }
     }
 
@@ -3567,6 +4225,11 @@
             GlStateManager.unlockBlend();
         }
 
+        if (programOld.getBlendStatesIndexed() != null)
+        {
+            GlStateManager.applyCurrentBlend();
+        }
+
         GlAlphaState glalphastate = programNew.getAlphaState();
 
         if (glalphastate != null)
@@ -3580,6 +4243,11 @@
         {
             GlStateManager.lockBlend(glblendstate);
         }
+
+        if (programNew.getBlendStatesIndexed() != null)
+        {
+            GlStateManager.setBlendsIndexed(programNew.getBlendStatesIndexed());
+        }
     }
 
     private static void setProgramUniform1i(ShaderUniform1i su, int value)
@@ -3607,57 +4275,54 @@
         su.setValue(transpose, matrix);
     }
 
-    public static int getBufferIndexFromString(String name)
+    public static int getBufferIndex(String name)
     {
-        if (!name.equals("colortex0") && !name.equals("gcolor"))
+        int i = ShaderParser.getIndex(name, "colortex", 0, 15);
+
+        if (i >= 0)
+        {
+            return i;
+        }
+        else
         {
-            if (!name.equals("colortex1") && !name.equals("gdepth"))
+            int j = ShaderParser.getIndex(name, "colorimg", 0, 15);
+
+            if (j >= 0)
             {
-                if (!name.equals("colortex2") && !name.equals("gnormal"))
-                {
-                    if (!name.equals("colortex3") && !name.equals("composite"))
-                    {
-                        if (!name.equals("colortex4") && !name.equals("gaux1"))
-                        {
-                            if (!name.equals("colortex5") && !name.equals("gaux2"))
-                            {
-                                if (!name.equals("colortex6") && !name.equals("gaux3"))
-                                {
-                                    return !name.equals("colortex7") && !name.equals("gaux4") ? -1 : 7;
-                                }
-                                else
-                                {
-                                    return 6;
-                                }
-                            }
-                            else
-                            {
-                                return 5;
-                            }
-                        }
-                        else
-                        {
-                            return 4;
-                        }
-                    }
-                    else
-                    {
-                        return 3;
-                    }
-                }
-                else
-                {
-                    return 2;
-                }
+                return j;
             }
-            else
+            else if (name.equals("gcolor"))
+            {
+                return 0;
+            }
+            else if (name.equals("gdepth"))
             {
                 return 1;
             }
-        }
-        else
-        {
-            return 0;
+            else if (name.equals("gnormal"))
+            {
+                return 2;
+            }
+            else if (name.equals("composite"))
+            {
+                return 3;
+            }
+            else if (name.equals("gaux1"))
+            {
+                return 4;
+            }
+            else if (name.equals("gaux2"))
+            {
+                return 5;
+            }
+            else if (name.equals("gaux3"))
+            {
+                return 6;
+            }
+            else
+            {
+                return name.equals("gaux4") ? 7 : -1;
+            }
         }
     }
 
@@ -3678,6 +4343,36 @@
         return 0;
     }
 
+    public static int getImageFormat(int textureFormat)
+    {
+        switch (textureFormat)
+        {
+            case 6407:
+                return 32849;
+
+            case 6408:
+                return 32856;
+
+            case 8194:
+                return 33321;
+
+            case 10768:
+                return 32849;
+
+            case 32855:
+                return 32856;
+
+            case 33319:
+                return 33323;
+
+            case 35901:
+                return 32852;
+
+            default:
+                return textureFormat;
+        }
+    }
+
     private static void setupNoiseTexture()
     {
         if (noiseTexture == null && noiseTexturePath != null)
@@ -3778,6 +4473,18 @@
         return buf;
     }
 
+    private static DrawBuffers fillIntBufferZero(DrawBuffers buf)
+    {
+        int i = buf.limit();
+
+        for (int j = buf.position(); j < i; ++j)
+        {
+            buf.put(j, 0);
+        }
+
+        return buf;
+    }
+
     public static void uninit()
     {
         if (isShaderPackInitialized)
@@ -3796,53 +4503,44 @@
 
                 program.setRef(0);
                 program.setId(0);
-                program.setDrawBufSettings((String)null);
-                program.setDrawBuffers((IntBuffer)null);
+                program.setDrawBufSettings((String[])null);
+                program.setDrawBuffers((DrawBuffers)null);
                 program.setCompositeMipmapSetting(0);
-            }
+                ComputeProgram[] acomputeprogram = program.getComputePrograms();
 
-            hasDeferredPrograms = false;
+                for (int j = 0; j < acomputeprogram.length; ++j)
+                {
+                    ComputeProgram computeprogram = acomputeprogram[j];
 
-            if (dfb != 0)
-            {
-                EXTFramebufferObject.glDeleteFramebuffersEXT(dfb);
-                dfb = 0;
-                checkGLError("del dfb");
-            }
+                    if (computeprogram.getRef() != 0)
+                    {
+                        ARBShaderObjects.glDeleteObjectARB(computeprogram.getRef());
+                        checkGLError("del programRef");
+                    }
 
-            if (sfb != 0)
-            {
-                EXTFramebufferObject.glDeleteFramebuffersEXT(sfb);
-                sfb = 0;
-                checkGLError("del sfb");
-            }
+                    computeprogram.setRef(0);
+                    computeprogram.setId(0);
+                }
 
-            if (dfbDepthTextures != null)
-            {
-                GlStateManager.deleteTextures(dfbDepthTextures);
-                fillIntBufferZero(dfbDepthTextures);
-                checkGLError("del dfbDepthTextures");
+                program.setComputePrograms(new ComputeProgram[0]);
             }
 
-            if (dfbColorTextures != null)
-            {
-                GlStateManager.deleteTextures(dfbColorTextures);
-                fillIntBufferZero(dfbColorTextures);
-                checkGLError("del dfbTextures");
-            }
+            hasDeferredPrograms = false;
+            hasShadowcompPrograms = false;
+            hasPreparePrograms = false;
 
-            if (sfbDepthTextures != null)
+            if (dfb != null)
             {
-                GlStateManager.deleteTextures(sfbDepthTextures);
-                fillIntBufferZero(sfbDepthTextures);
-                checkGLError("del shadow depth");
+                dfb.delete();
+                dfb = null;
+                checkGLError("del dfb");
             }
 
-            if (sfbColorTextures != null)
+            if (sfb != null)
             {
-                GlStateManager.deleteTextures(sfbColorTextures);
-                fillIntBufferZero(sfbColorTextures);
-                checkGLError("del shadow color");
+                sfb.delete();
+                sfb = null;
+                checkGLError("del sfb");
             }
 
             if (dfbDrawBuffers != null)
@@ -3850,14 +4548,24 @@
                 fillIntBufferZero(dfbDrawBuffers);
             }
 
+            if (sfbDrawBuffers != null)
+            {
+                fillIntBufferZero(sfbDrawBuffers);
+            }
+
             if (noiseTexture != null)
             {
                 noiseTexture.deleteTexture();
                 noiseTexture = null;
             }
 
+            for (int k = 0; k < colorImageUnit.length; ++k)
+            {
+                GlStateManager.bindImageTexture(colorImageUnit[k], 0, 0, false, 0, 35000, 32856);
+            }
+
             SMCLog.info("Uninit");
-            shadowPassInterval = 0;
+            hasShadowMap = false;
             shouldSkipDefaultShadow = false;
             isShaderPackInitialized = false;
             checkGLError("Shaders.uninit");
@@ -3878,8 +4586,9 @@
     {
         renderDisplayWidth = mc.getMainWindow().getFramebufferWidth();
         renderDisplayHeight = mc.getMainWindow().getFramebufferHeight();
-        renderWidth = Math.round((float)renderDisplayWidth * configRenderResMul);
-        renderHeight = Math.round((float)renderDisplayHeight * configRenderResMul);
+        renderWidth = Math.round((float)renderDisplayWidth);
+        renderHeight = Math.round((float)renderDisplayHeight);
+        System.out.println("Shaders Render Res: " + renderWidth + " x " + renderHeight);
         setupFrameBuffer();
     }
 
@@ -3893,184 +4602,80 @@
 
     private static void setupFrameBuffer()
     {
-        if (dfb != 0)
-        {
-            EXTFramebufferObject.glDeleteFramebuffersEXT(dfb);
-            GlStateManager.deleteTextures(dfbDepthTextures);
-            GlStateManager.deleteTextures(dfbColorTextures);
-        }
-
-        dfb = EXTFramebufferObject.glGenFramebuffersEXT();
-        GL32.glGenTextures((IntBuffer)((Buffer)dfbDepthTextures).clear().limit(usedDepthBuffers));
-        GL32.glGenTextures((IntBuffer)((Buffer)dfbColorTextures).clear().limit(16));
-        ((Buffer)dfbDepthTextures).position(0);
-        ((Buffer)dfbColorTextures).position(0);
-        EXTFramebufferObject.glBindFramebufferEXT(36160, dfb);
-        GL32.glDrawBuffers(0);
-        GL32.glReadBuffer(0);
-
-        for (int i = 0; i < usedDepthBuffers; ++i)
-        {
-            GlStateManager.bindTexture(dfbDepthTextures.get(i));
-            GL32.glTexParameteri(3553, 10242, 33071);
-            GL32.glTexParameteri(3553, 10243, 33071);
-            GL32.glTexParameteri(3553, 10241, 9728);
-            GL32.glTexParameteri(3553, 10240, 9728);
-            GL32.glTexParameteri(3553, 34891, 6409);
-            GL32.glTexImage2D(3553, 0, 6402, renderWidth, renderHeight, 0, 6402, 5126, (FloatBuffer)null);
-        }
-
-        EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36096, 3553, dfbDepthTextures.get(0), 0);
-        GL32.glDrawBuffers(dfbDrawBuffers);
-        GL32.glReadBuffer(0);
-        checkGLError("FT d");
-
-        for (int k = 0; k < usedColorBuffers; ++k)
-        {
-            GlStateManager.bindTexture(dfbColorTexturesFlip.getA(k));
-            GL32.glTexParameteri(3553, 10242, 33071);
-            GL32.glTexParameteri(3553, 10243, 33071);
-            GL32.glTexParameteri(3553, 10241, 9729);
-            GL32.glTexParameteri(3553, 10240, 9729);
-            GL32.glTexImage2D(3553, 0, gbuffersFormat[k], renderWidth, renderHeight, 0, getPixelFormat(gbuffersFormat[k]), 33639, (ByteBuffer)null);
-            EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064 + k, 3553, dfbColorTexturesFlip.getA(k), 0);
-            checkGLError("FT c");
-        }
-
-        for (int l = 0; l < usedColorBuffers; ++l)
+        if (dfb != null)
         {
-            GlStateManager.bindTexture(dfbColorTexturesFlip.getB(l));
-            GL32.glTexParameteri(3553, 10242, 33071);
-            GL32.glTexParameteri(3553, 10243, 33071);
-            GL32.glTexParameteri(3553, 10241, 9729);
-            GL32.glTexParameteri(3553, 10240, 9729);
-            GL32.glTexImage2D(3553, 0, gbuffersFormat[l], renderWidth, renderHeight, 0, getPixelFormat(gbuffersFormat[l]), 33639, (ByteBuffer)null);
-            checkGLError("FT ca");
+            dfb.delete();
         }
 
-        int i1 = EXTFramebufferObject.glCheckFramebufferStatusEXT(36160);
+        boolean[] aboolean = ArrayUtils.newBoolean(usedDepthBuffers, true);
+        boolean[] aboolean1 = new boolean[usedDepthBuffers];
+        boolean[] aboolean2 = new boolean[usedColorBuffers];
+        int[] aint = bindImageTextures ? colorImageUnit : null;
+        dfb = new ShadersFramebuffer("dfb", renderWidth, renderHeight, usedColorBuffers, usedDepthBuffers, 8, aboolean, aboolean1, aboolean2, colorBufferSizes, gbuffersFormat, colorTextureImageUnit, depthTextureImageUnit, aint, dfbDrawBuffers);
+        dfb.setup();
+    }
 
-        if (i1 == 36058)
+    public static int getPixelFormat(int internalFormat)
+    {
+        switch (internalFormat)
         {
-            printChatAndLogError("[Shaders] Error: Failed framebuffer incomplete formats");
-
-            for (int j = 0; j < usedColorBuffers; ++j)
-            {
-                GlStateManager.bindTexture(dfbColorTexturesFlip.getA(j));
-                GL32.glTexImage2D(3553, 0, 6408, renderWidth, renderHeight, 0, 32993, 33639, (ByteBuffer)null);
-                EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064 + j, 3553, dfbColorTexturesFlip.getA(j), 0);
-                checkGLError("FT c");
-            }
-
-            i1 = EXTFramebufferObject.glCheckFramebufferStatusEXT(36160);
+            case 33329:
+            case 33335:
+            case 36238:
+            case 36239:
+                return 36251;
 
-            if (i1 == 36053)
-            {
-                SMCLog.info("complete");
-            }
-        }
+            case 33330:
+            case 33336:
+            case 36220:
+            case 36221:
+                return 36251;
 
-        GlStateManager.bindTexture(0);
+            case 33331:
+            case 33337:
+            case 36232:
+            case 36233:
+                return 36251;
 
-        if (i1 != 36053)
-        {
-            printChatAndLogError("[Shaders] Error: Failed creating framebuffer! (Status " + i1 + ")");
-        }
-        else
-        {
-            SMCLog.info("Framebuffer created.");
-        }
-    }
+            case 33332:
+            case 33338:
+            case 36214:
+            case 36215:
+                return 36251;
 
-    private static int getPixelFormat(int internalFormat)
-    {
-        switch (internalFormat)
-        {
             case 33333:
-            case 33334:
             case 33339:
+            case 36226:
+            case 36227:
+                return 36251;
+
+            case 33334:
             case 33340:
             case 36208:
             case 36209:
-            case 36226:
-            case 36227:
                 return 36251;
 
             default:
                 return 32993;
         }
-    }
-
-    private static void setupShadowFrameBuffer()
-    {
-        if (usedShadowDepthBuffers != 0)
-        {
-            if (sfb != 0)
-            {
-                EXTFramebufferObject.glDeleteFramebuffersEXT(sfb);
-                GlStateManager.deleteTextures(sfbDepthTextures);
-                GlStateManager.deleteTextures(sfbColorTextures);
-            }
-
-            sfb = EXTFramebufferObject.glGenFramebuffersEXT();
-            EXTFramebufferObject.glBindFramebufferEXT(36160, sfb);
-            GL32.glDrawBuffer(0);
-            GL32.glReadBuffer(0);
-            GL32.glGenTextures((IntBuffer)((Buffer)sfbDepthTextures).clear().limit(usedShadowDepthBuffers));
-            GL32.glGenTextures((IntBuffer)((Buffer)sfbColorTextures).clear().limit(usedShadowColorBuffers));
-            ((Buffer)sfbDepthTextures).position(0);
-            ((Buffer)sfbColorTextures).position(0);
-
-            for (int i = 0; i < usedShadowDepthBuffers; ++i)
-            {
-                GlStateManager.bindTexture(sfbDepthTextures.get(i));
-                GL32.glTexParameterf(3553, 10242, 33071.0F);
-                GL32.glTexParameterf(3553, 10243, 33071.0F);
-                int j = shadowFilterNearest[i] ? 9728 : 9729;
-                GL32.glTexParameteri(3553, 10241, j);
-                GL32.glTexParameteri(3553, 10240, j);
-
-                if (shadowHardwareFilteringEnabled[i])
-                {
-                    GL32.glTexParameteri(3553, 34892, 34894);
-                }
-
-                GL32.glTexImage2D(3553, 0, 6402, shadowMapWidth, shadowMapHeight, 0, 6402, 5126, (FloatBuffer)null);
-            }
-
-            EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36096, 3553, sfbDepthTextures.get(0), 0);
-            checkGLError("FT sd");
-
-            for (int k = 0; k < usedShadowColorBuffers; ++k)
-            {
-                GlStateManager.bindTexture(sfbColorTextures.get(k));
-                GL32.glTexParameterf(3553, 10242, 33071.0F);
-                GL32.glTexParameterf(3553, 10243, 33071.0F);
-                int i1 = shadowColorFilterNearest[k] ? 9728 : 9729;
-                GL32.glTexParameteri(3553, 10241, i1);
-                GL32.glTexParameteri(3553, 10240, i1);
-                GL32.glTexImage2D(3553, 0, 6408, shadowMapWidth, shadowMapHeight, 0, 32993, 33639, (ByteBuffer)null);
-                EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064 + k, 3553, sfbColorTextures.get(k), 0);
-                checkGLError("FT sc");
-            }
+    }
 
-            GlStateManager.bindTexture(0);
+    private static void setupShadowFrameBuffer()
+    {
+        if (hasShadowMap)
+        {
+            isShadowPass = true;
 
-            if (usedShadowColorBuffers > 0)
+            if (sfb != null)
             {
-                GL32.glDrawBuffers(sfbDrawBuffers);
+                sfb.delete();
             }
 
-            int l = EXTFramebufferObject.glCheckFramebufferStatusEXT(36160);
-
-            if (l != 36053)
-            {
-                printChatAndLogError("[Shaders] Error: Failed creating shadow framebuffer! (Status " + l + ")");
-            }
-            else
-            {
-                SMCLog.info("Shadow framebuffer created.");
-            }
+            DynamicDimension[] adynamicdimension = new DynamicDimension[2];
+            int[] aint = bindImageTextures ? shadowColorImageUnit : null;
+            sfb = new ShadersFramebuffer("sfb", shadowMapWidth, shadowMapHeight, usedShadowColorBuffers, usedShadowDepthBuffers, 8, shadowFilterNearest, shadowHardwareFilteringEnabled, shadowColorFilterNearest, adynamicdimension, shadowBuffersFormat, shadowColorTextureImageUnit, shadowDepthTextureImageUnit, aint, sfbDrawBuffers);
+            sfb.setup();
+            isShadowPass = false;
         }
     }
 
@@ -4100,9 +4705,10 @@
             }
         }
 
-        if (mc.getMainWindow().getFramebufferWidth() != renderDisplayWidth || mc.getMainWindow().getFramebufferHeight() != renderDisplayHeight)
+        if (mc.stereoProvider.reinitShadersFlag || mc.getMainWindow().getFramebufferWidth() != renderDisplayWidth || mc.getMainWindow().getFramebufferHeight() != renderDisplayHeight)
         {
             resize();
+            mc.stereoProvider.reinitShadersFlag  = false;
         }
 
         if (needResizeShadow)
@@ -4129,6 +4735,8 @@
         frameTime = (float)diffSystemTime / 1000.0F;
         frameTimeCounter += frameTime;
         frameTimeCounter %= 3600.0F;
+        pointOfViewChanged = pointOfView != mc.gameSettings.getPointOfView();
+        pointOfView = mc.gameSettings.getPointOfView();
         GlStateManager.pushMatrix();
         ShadersRender.updateActiveRenderInfo(activeRenderInfo, minecraft, partialTicks);
         GlStateManager.popMatrix();
@@ -4154,7 +4762,7 @@
 
             if (entity != null)
             {
-                isSleeping = entity instanceof LivingEntity && ((LivingEntity)entity).isSleeping();
+                isSleeping = false;//entity instanceof LivingEntity && ((LivingEntity)entity).isSleeping();
                 eyePosY = (float)activeRenderInfo.getProjectedView().getY();
                 eyeBrightness = mc.getRenderManager().getPackedLight(entity, partialTicks);
                 float f2 = (float)diffSystemTime * 0.01F;
@@ -4183,7 +4791,6 @@
 
                     if (livingentity.isPotionActive(Effects.NIGHT_VISION))
                     {
-                        GameRenderer gamerenderer = entityRenderer;
                         nightVision = GameRenderer.getNightVisionBrightness(livingentity, partialTicks);
                     }
 
@@ -4211,7 +4818,15 @@
         isHandRenderedOff = false;
         skipRenderHandMain = false;
         skipRenderHandOff = false;
+        dfb.setColorBuffersFiltering(9729, 9729);
         bindGbuffersTextures();
+        dfb.bindColorImages(true);
+
+        if (sfb != null)
+        {
+            sfb.bindColorImages(true);
+        }
+
         previousCameraPositionX = cameraPositionX;
         previousCameraPositionY = cameraPositionY;
         previousCameraPositionZ = cameraPositionZ;
@@ -4226,81 +4841,39 @@
         ((Buffer)previousModelView).position(0);
         ((Buffer)modelView).position(0);
         checkGLError("beginRender");
-        ShadersRender.renderShadowMap(entityRenderer, activeRenderInfo, 0, partialTicks, finishTimeNano);
+		// VIVECRAFT: Render shadow map once per frame instead of every damn pass
+		if (mc.currentPass == RenderPass.LEFT || mc.currentPass == RenderPass.THIRD || mc.currentPass == RenderPass.CAMERA)
+			ShadersRender.renderShadowMap(entityRenderer, entityRenderer.getActiveRenderInfo(), 0, partialTicks, finishTimeNano);
         mc.getProfiler().endSection();
-        EXTFramebufferObject.glBindFramebufferEXT(36160, dfb);
-
-        for (int j = 0; j < usedColorBuffers; ++j)
-        {
-            EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064 + j, 3553, dfbColorTexturesFlip.getA(j), 0);
-        }
-
+        dfb.setColorTextures(true);
+        setRenderStage(RenderStage.NONE);
         checkGLError("end beginRender");
     }
 
     private static void bindGbuffersTextures()
     {
-        if (usedShadowDepthBuffers >= 1)
-        {
-            GlStateManager.activeTexture(33988);
-            GlStateManager.bindTexture(sfbDepthTextures.get(0));
-
-            if (usedShadowDepthBuffers >= 2)
-            {
-                GlStateManager.activeTexture(33989);
-                GlStateManager.bindTexture(sfbDepthTextures.get(1));
-            }
-        }
-
-        GlStateManager.activeTexture(33984);
-
-        for (int i = 0; i < usedColorBuffers; ++i)
-        {
-            GlStateManager.bindTexture(dfbColorTexturesFlip.getA(i));
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
-            GlStateManager.bindTexture(dfbColorTexturesFlip.getB(i));
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
-            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
-        }
-
-        GlStateManager.bindTexture(0);
-
-        for (int j = 0; j < 4 && 4 + j < usedColorBuffers; ++j)
-        {
-            GlStateManager.activeTexture(33991 + j);
-            GlStateManager.bindTexture(dfbColorTexturesFlip.getA(4 + j));
-        }
-
-        GlStateManager.activeTexture(33990);
-        GlStateManager.bindTexture(dfbDepthTextures.get(0));
+        bindTextures(4, customTexturesGbuffers);
+    }
 
-        if (usedDepthBuffers >= 2)
+    private static void bindTextures(int startColorBuffer, ICustomTexture[] customTextures)
+    {
+        if (sfb != null)
         {
-            GlStateManager.activeTexture(33995);
-            GlStateManager.bindTexture(dfbDepthTextures.get(1));
-
-            if (usedDepthBuffers >= 3)
-            {
-                GlStateManager.activeTexture(33996);
-                GlStateManager.bindTexture(dfbDepthTextures.get(2));
-            }
+            sfb.bindColorTextures(0);
+            sfb.bindDepthTextures(shadowDepthTextureImageUnit);
         }
 
-        for (int k = 0; k < usedShadowColorBuffers; ++k)
-        {
-            GlStateManager.activeTexture(33997 + k);
-            GlStateManager.bindTexture(sfbColorTextures.get(k));
-        }
+        dfb.bindColorTextures(startColorBuffer);
+        dfb.bindDepthTextures(depthTextureImageUnit);
 
         if (noiseTextureEnabled)
         {
             GlStateManager.activeTexture(33984 + noiseTexture.getTextureUnit());
             GlStateManager.bindTexture(noiseTexture.getTextureId());
+            GlStateManager.activeTexture(33984);
         }
 
-        bindCustomTextures(customTexturesGbuffers);
-        GlStateManager.activeTexture(33984);
+        bindCustomTextures(customTextures);
     }
 
     public static void checkWorldChanged(ClientWorld worldin)
@@ -4343,9 +4916,9 @@
     {
         if (!isShadowPass)
         {
-            EXTFramebufferObject.glBindFramebufferEXT(36160, dfb);
+            dfb.bindFramebuffer();
             GL11.glViewport(0, 0, renderWidth, renderHeight);
-            activeDrawBuffers = null;
+            GlState.setDrawBuffers((DrawBuffers)null);
             ShadersTex.bindNSTextures(defaultTexture.getMultiTexID());
             useProgram(ProgramTextured);
             checkGLError("end beginRenderPass");
@@ -4363,11 +4936,11 @@
         else
         {
             GL11.glViewport(0, 0, renderWidth, renderHeight);
-            EXTFramebufferObject.glBindFramebufferEXT(36160, dfb);
+            dfb.bindFramebuffer();
             isRenderingDfb = true;
             GlStateManager.enableCull();
             GlStateManager.enableDepthTest();
-            setDrawBuffers(drawBuffersNone);
+            GlState.setDrawBuffers(drawBuffersNone);
             useProgram(ProgramTextured);
             checkGLError("beginRenderPass");
         }
@@ -4393,9 +4966,7 @@
 
     public static void setClearColor(float red, float green, float blue, float alpha)
     {
-        clearColorR = red;
-        clearColorG = green;
-        clearColorB = blue;
+        clearColor.set(red, green, blue, 1.0F);
     }
 
     public static void clearRenderBuffer()
@@ -4403,88 +4974,52 @@
         if (isShadowPass)
         {
             checkGLError("shadow clear pre");
-            EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36096, 3553, sfbDepthTextures.get(0), 0);
-            GL32.glClearColor(1.0F, 1.0F, 1.0F, 1.0F);
-            GL32.glDrawBuffers(ProgramShadow.getDrawBuffers());
-            checkFramebufferStatus("shadow clear");
-            GL32.glClear(16640);
+            sfb.clearDepthBuffer(new Vector4f(1.0F, 1.0F, 1.0F, 1.0F));
             checkGLError("shadow clear");
         }
         else
         {
             checkGLError("clear pre");
+            Vector4f[] avector4f = new Vector4f[usedColorBuffers];
 
-            if (gbuffersClear[0])
-            {
-                Vector4f vector4f = gbuffersClearColor[0];
-
-                if (vector4f != null)
-                {
-                    GL32.glClearColor(vector4f.getX(), vector4f.getY(), vector4f.getZ(), vector4f.getW());
-                }
-
-                if (dfbColorTexturesFlip.isChanged(0))
-                {
-                    EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064, 3553, dfbColorTexturesFlip.getB(0), 0);
-                    GL32.glDrawBuffers(36064);
-                    GL32.glClear(16384);
-                    EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064, 3553, dfbColorTexturesFlip.getA(0), 0);
-                }
-
-                GL32.glDrawBuffers(36064);
-                GL32.glClear(16384);
-            }
-
-            if (gbuffersClear[1])
+            for (int i = 0; i < avector4f.length; ++i)
             {
-                GL32.glClearColor(1.0F, 1.0F, 1.0F, 1.0F);
-                Vector4f vector4f2 = gbuffersClearColor[1];
-
-                if (vector4f2 != null)
-                {
-                    GL32.glClearColor(vector4f2.getX(), vector4f2.getY(), vector4f2.getZ(), vector4f2.getW());
-                }
-
-                if (dfbColorTexturesFlip.isChanged(1))
-                {
-                    EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36065, 3553, dfbColorTexturesFlip.getB(1), 0);
-                    GL32.glDrawBuffers(36065);
-                    GL32.glClear(16384);
-                    EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36065, 3553, dfbColorTexturesFlip.getA(1), 0);
-                }
-
-                GL32.glDrawBuffers(36065);
-                GL32.glClear(16384);
+                avector4f[i] = getBufferClearColor(i);
             }
 
-            for (int i = 2; i < usedColorBuffers; ++i)
-            {
-                if (gbuffersClear[i])
-                {
-                    GL32.glClearColor(0.0F, 0.0F, 0.0F, 0.0F);
-                    Vector4f vector4f1 = gbuffersClearColor[i];
-
-                    if (vector4f1 != null)
-                    {
-                        GL32.glClearColor(vector4f1.getX(), vector4f1.getY(), vector4f1.getZ(), vector4f1.getW());
-                    }
+            dfb.clearColorBuffers(gbuffersClear, avector4f);
+            dfb.setDrawBuffers();
+            checkFramebufferStatus("clear");
+            checkGLError("clear");
+        }
+    }
 
-                    if (dfbColorTexturesFlip.isChanged(i))
-                    {
-                        EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064 + i, 3553, dfbColorTexturesFlip.getB(i), 0);
-                        GL32.glDrawBuffers(36064 + i);
-                        GL32.glClear(16384);
-                        EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064 + i, 3553, dfbColorTexturesFlip.getA(i), 0);
-                    }
+    public static void renderPrepare()
+    {
+        if (hasPreparePrograms)
+        {
+            renderPrepareComposites();
+            bindGbuffersTextures();
+            dfb.setDrawBuffers();
+            dfb.setColorTextures(true);
+        }
+    }
 
-                    GL32.glDrawBuffers(36064 + i);
-                    GL32.glClear(16384);
-                }
-            }
+    private static Vector4f getBufferClearColor(int buffer)
+    {
+        Vector4f vector4f = gbuffersClearColor[buffer];
 
-            setDrawBuffers(dfbDrawBuffers);
-            checkFramebufferStatus("clear");
-            checkGLError("clear");
+        if (vector4f != null)
+        {
+            return vector4f;
+        }
+        else if (buffer == 0)
+        {
+            return clearColor;
+        }
+        else
+        {
+            return buffer == 1 ? CLEAR_COLOR_1 : CLEAR_COLOR_0;
         }
     }
 
@@ -4499,14 +5034,16 @@
         cameraPositionX = d0 - (double)cameraOffsetX;
         cameraPositionY = d1;
         cameraPositionZ = d2 - (double)cameraOffsetZ;
-        GL32.glGetFloatv(2983, (FloatBuffer)((Buffer)projection).position(0));
-        SMath.invertMat4FBFA((FloatBuffer)((Buffer)projectionInverse).position(0), (FloatBuffer)((Buffer)projection).position(0), faProjectionInverse, faProjection);
-        ((Buffer)projection).position(0);
-        ((Buffer)projectionInverse).position(0);
+        updateProjectionMatrix();
         Matrix4f matrix4f = matrixStackIn.getLast().getMatrix();
-        Matrix4f matrix4f1 = new Matrix4f(matrix4f);
-        matrix4f1.transpose();
-        matrix4f1.write(tempMat);
+        //Vivecraft - I do not know why this is necessary to fix shadows. It should be in stereo already.
+        MatrixStack mat = new MatrixStack();
+        mat.getLast().getMatrix().setIdentity();
+        mat.getLast().getMatrix().mul(matrix4f);
+        entityRenderer.applystereo(mc.currentPass, mat);
+        //
+        mat.getLast().getMatrix().transpose();
+        mat.getLast().getMatrix().write(tempMat);
         ((Buffer)modelView).position(0);
         modelView.put(tempMat);
         SMath.invertMat4FBFA((FloatBuffer)((Buffer)modelViewInverse).position(0), (FloatBuffer)((Buffer)modelView).position(0), faModelViewInverse, faModelView);
@@ -4515,6 +5052,22 @@
         checkGLError("setCamera");
     }
 
+    public static void updateProjectionMatrix()
+    {
+        GL43.glGetFloatv(2983, (FloatBuffer)((Buffer)projection).position(0));
+        SMath.invertMat4FBFA((FloatBuffer)((Buffer)projectionInverse).position(0), (FloatBuffer)((Buffer)projection).position(0), faProjectionInverse, faProjection);
+        ((Buffer)projection).position(0);
+        ((Buffer)projectionInverse).position(0);
+    }
+
+    private static void updateShadowProjectionMatrix()
+    {
+        GL43.glGetFloatv(2983, (FloatBuffer)((Buffer)shadowProjection).position(0));
+        SMath.invertMat4FBFA((FloatBuffer)((Buffer)shadowProjectionInverse).position(0), (FloatBuffer)((Buffer)shadowProjection).position(0), faShadowProjectionInverse, faShadowProjection);
+        ((Buffer)shadowProjection).position(0);
+        ((Buffer)shadowProjectionInverse).position(0);
+    }
+
     private static void updateCameraOffset(Entity viewEntity)
     {
         double d0 = Math.abs(cameraPositionX - previousCameraPositionX);
@@ -4553,13 +5106,13 @@
         cameraPositionX = d0 - (double)cameraOffsetX;
         cameraPositionY = d1;
         cameraPositionZ = d2 - (double)cameraOffsetZ;
-        GL32.glViewport(0, 0, shadowMapWidth, shadowMapHeight);
-        GL32.glMatrixMode(5889);
-        GL32.glLoadIdentity();
+        GL43.glViewport(0, 0, shadowMapWidth, shadowMapHeight);
+        GL43.glMatrixMode(5889);
+        GL43.glLoadIdentity();
 
         if (shadowMapIsOrtho)
         {
-            GL32.glOrtho((double)(-shadowMapHalfPlane), (double)shadowMapHalfPlane, (double)(-shadowMapHalfPlane), (double)shadowMapHalfPlane, (double)0.05F, 256.0D);
+            GL43.glOrtho((double)(-shadowMapHalfPlane), (double)shadowMapHalfPlane, (double)(-shadowMapHalfPlane), (double)shadowMapHalfPlane, (double)0.05F, 256.0D);
         }
         else
         {
@@ -4612,10 +5165,7 @@
         shadowLightPositionVector[1] = f7;
         shadowLightPositionVector[2] = f8;
         shadowLightPositionVector[3] = 0.0F;
-        GL32.glGetFloatv(2983, (FloatBuffer)((Buffer)shadowProjection).position(0));
-        SMath.invertMat4FBFA((FloatBuffer)((Buffer)shadowProjectionInverse).position(0), (FloatBuffer)((Buffer)shadowProjection).position(0), faShadowProjectionInverse, faShadowProjection);
-        ((Buffer)shadowProjection).position(0);
-        ((Buffer)shadowProjectionInverse).position(0);
+        updateShadowProjectionMatrix();
         Matrix4f matrix4f = matrixStack.getLast().getMatrix();
         matrix4f.write((FloatBuffer)((Buffer)shadowModelView).position(0));
         SMath.invertMat4FBFA((FloatBuffer)((Buffer)shadowModelViewInverse).position(0), (FloatBuffer)((Buffer)shadowModelView).position(0), faShadowModelViewInverse, faShadowModelView);
@@ -4646,13 +5196,24 @@
         Matrix4f matrix4f1 = new Matrix4f(matrix4f);
         matrix4f1.transpose();
         matrix4f1.write(tempMat);
+    	if(Minecraft.getInstance().currentPass == RenderPass.THIRD) {
+    		//Vivecraft
+    		SMath.multiplyMat4xVec4(sunPositionT, tempMat, sunPosModelView);
+    		SMath.multiplyMat4xVec4(moonPositionT, tempMat, moonPosModelView);
+    		System.arraycopy(shadowAngle == sunAngle ? sunPositionT : moonPosition, 0, shadowLightPosition, 0, 3);
+    		setProgramUniform3f(uniform_sunPosition, sunPositionT[0], sunPositionT[1], sunPositionT[2]);
+    		setProgramUniform3f(uniform_moonPosition, moonPositionT[0], moonPositionT[1], moonPositionT[2]);
+    		setProgramUniform3f(uniform_shadowLightPosition, shadowLightPosition[0], shadowLightPosition[1], shadowLightPosition[2]);
+    		//
+    	}
+    	else {
         SMath.multiplyMat4xVec4(sunPosition, tempMat, sunPosModelView);
         SMath.multiplyMat4xVec4(moonPosition, tempMat, moonPosModelView);
         System.arraycopy(shadowAngle == sunAngle ? sunPosition : moonPosition, 0, shadowLightPosition, 0, 3);
         setProgramUniform3f(uniform_sunPosition, sunPosition[0], sunPosition[1], sunPosition[2]);
         setProgramUniform3f(uniform_moonPosition, moonPosition[0], moonPosition[1], moonPosition[2]);
         setProgramUniform3f(uniform_shadowLightPosition, shadowLightPosition[0], shadowLightPosition[1], shadowLightPosition[2]);
-
+	}
         if (customUniforms != null)
         {
             customUniforms.update();
@@ -4676,27 +5237,9 @@
         }
     }
 
-    public static void genCompositeMipmap()
-    {
-        if (hasGlGenMipmap)
-        {
-            for (int i = 0; i < usedColorBuffers; ++i)
-            {
-                if ((activeCompositeMipmapSetting & 1 << i) != 0)
-                {
-                    GlStateManager.activeTexture(33984 + colorTextureImageUnit[i]);
-                    GL32.glTexParameteri(3553, 10241, 9987);
-                    GL32.glGenerateMipmap(3553);
-                }
-            }
-
-            GlStateManager.activeTexture(33984);
-        }
-    }
-
     public static void drawComposite()
     {
-        GL32.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        GL43.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
         drawCompositeQuad();
         int i = activeProgram.getCountInstances();
 
@@ -4716,29 +5259,29 @@
     {
         if (!canRenderQuads())
         {
-            GL32.glBegin(5);
-            GL32.glTexCoord2f(0.0F, 0.0F);
-            GL32.glVertex3f(0.0F, 0.0F, 0.0F);
-            GL32.glTexCoord2f(1.0F, 0.0F);
-            GL32.glVertex3f(1.0F, 0.0F, 0.0F);
-            GL32.glTexCoord2f(0.0F, 1.0F);
-            GL32.glVertex3f(0.0F, 1.0F, 0.0F);
-            GL32.glTexCoord2f(1.0F, 1.0F);
-            GL32.glVertex3f(1.0F, 1.0F, 0.0F);
-            GL32.glEnd();
+            GL43.glBegin(5);
+            GL43.glTexCoord2f(0.0F, 0.0F);
+            GL43.glVertex3f(0.0F, 0.0F, 0.0F);
+            GL43.glTexCoord2f(1.0F, 0.0F);
+            GL43.glVertex3f(1.0F, 0.0F, 0.0F);
+            GL43.glTexCoord2f(0.0F, 1.0F);
+            GL43.glVertex3f(0.0F, 1.0F, 0.0F);
+            GL43.glTexCoord2f(1.0F, 1.0F);
+            GL43.glVertex3f(1.0F, 1.0F, 0.0F);
+            GL43.glEnd();
         }
         else
         {
-            GL32.glBegin(7);
-            GL32.glTexCoord2f(0.0F, 0.0F);
-            GL32.glVertex3f(0.0F, 0.0F, 0.0F);
-            GL32.glTexCoord2f(1.0F, 0.0F);
-            GL32.glVertex3f(1.0F, 0.0F, 0.0F);
-            GL32.glTexCoord2f(1.0F, 1.0F);
-            GL32.glVertex3f(1.0F, 1.0F, 0.0F);
-            GL32.glTexCoord2f(0.0F, 1.0F);
-            GL32.glVertex3f(0.0F, 1.0F, 0.0F);
-            GL32.glEnd();
+            GL43.glBegin(7);
+            GL43.glTexCoord2f(0.0F, 0.0F);
+            GL43.glVertex3f(0.0F, 0.0F, 0.0F);
+            GL43.glTexCoord2f(1.0F, 0.0F);
+            GL43.glVertex3f(1.0F, 0.0F, 0.0F);
+            GL43.glTexCoord2f(1.0F, 1.0F);
+            GL43.glVertex3f(1.0F, 1.0F, 0.0F);
+            GL43.glTexCoord2f(0.0F, 1.0F);
+            GL43.glVertex3f(0.0F, 1.0F, 0.0F);
+            GL43.glEnd();
         }
     }
 
@@ -4746,33 +5289,21 @@
     {
         if (!isShadowPass)
         {
-            boolean flag = checkBufferFlip(ProgramDeferredPre);
+            boolean flag = checkBufferFlip(dfb, ProgramDeferredPre);
 
             if (hasDeferredPrograms)
             {
                 checkGLError("pre-render Deferred");
-                renderComposites(ProgramsDeferred, false);
+                renderDeferredComposites();
                 flag = true;
             }
 
             if (flag)
             {
                 bindGbuffersTextures();
-
-                for (int i = 0; i < usedColorBuffers; ++i)
-                {
-                    EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064 + i, 3553, dfbColorTexturesFlip.getA(i), 0);
-                }
-
-                if (ProgramWater.getDrawBuffers() != null)
-                {
-                    setDrawBuffers(ProgramWater.getDrawBuffers());
-                }
-                else
-                {
-                    setDrawBuffers(dfbDrawBuffers);
-                }
-
+                dfb.setColorTextures(true);
+                DrawBuffers drawbuffers = ProgramWater.getDrawBuffers() != null ? ProgramWater.getDrawBuffers() : dfb.getDrawBuffers();
+                GlState.setDrawBuffers(drawbuffers);
                 GlStateManager.activeTexture(33984);
                 mc.getTextureManager().bindTexture(AtlasTexture.LOCATION_BLOCKS_TEXTURE);
             }
@@ -4783,13 +5314,13 @@
     {
         if (!isShadowPass)
         {
-            checkBufferFlip(ProgramCompositePre);
+            checkBufferFlip(dfb, ProgramCompositePre);
             checkGLError("pre-render CompositeFinal");
-            renderComposites(ProgramsComposite, true);
+            renderComposites();
         }
     }
 
-    private static boolean checkBufferFlip(Program program)
+    private static boolean checkBufferFlip(ShadersFramebuffer framebuffer, Program program)
     {
         boolean flag = false;
         Boolean[] aboolean = program.getBuffersFlip();
@@ -4798,7 +5329,7 @@
         {
             if (Config.isTrue(aboolean[i]))
             {
-                dfbColorTexturesFlip.flip(i);
+                framebuffer.flipColorTexture(i);
                 flag = true;
             }
         }
@@ -4806,178 +5337,218 @@
         return flag;
     }
 
-    private static void renderComposites(Program[] ps, boolean renderFinal)
+    private static void renderComposites()
     {
         if (!isShadowPass)
         {
-            GL32.glPushMatrix();
-            GL32.glLoadIdentity();
-            GL32.glMatrixMode(5889);
-            GL32.glPushMatrix();
-            GL32.glLoadIdentity();
-            GL32.glOrtho(0.0D, 1.0D, 0.0D, 1.0D, 0.0D, 1.0D);
-            GL32.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
-            GlStateManager.enableTexture();
-            GlStateManager.disableAlphaTest();
-            GlStateManager.disableBlend();
-            GlStateManager.enableDepthTest();
-            GlStateManager.depthFunc(519);
-            GlStateManager.depthMask(false);
-            GlStateManager.disableLighting();
-
-            if (usedShadowDepthBuffers >= 1)
-            {
-                GlStateManager.activeTexture(33988);
-                GlStateManager.bindTexture(sfbDepthTextures.get(0));
-
-                if (usedShadowDepthBuffers >= 2)
-                {
-                    GlStateManager.activeTexture(33989);
-                    GlStateManager.bindTexture(sfbDepthTextures.get(1));
-                }
-            }
+            renderComposites(ProgramsComposite, true, customTexturesComposite);
+        }
+    }
 
-            for (int i = 0; i < usedColorBuffers; ++i)
-            {
-                GlStateManager.activeTexture(33984 + colorTextureImageUnit[i]);
-                GlStateManager.bindTexture(dfbColorTexturesFlip.getA(i));
-            }
+    private static void renderDeferredComposites()
+    {
+        if (!isShadowPass)
+        {
+            renderComposites(ProgramsDeferred, false, customTexturesDeferred);
+        }
+    }
 
-            GlStateManager.activeTexture(33990);
-            GlStateManager.bindTexture(dfbDepthTextures.get(0));
+    public static void renderPrepareComposites()
+    {
+        renderComposites(ProgramsPrepare, false, customTexturesPrepare);
+    }
 
-            if (usedDepthBuffers >= 2)
-            {
-                GlStateManager.activeTexture(33995);
-                GlStateManager.bindTexture(dfbDepthTextures.get(1));
+    private static void renderComposites(Program[] ps, boolean renderFinal, ICustomTexture[] customTextures)
+    {
+        renderComposites(dfb, ps, renderFinal, customTextures);
+    }
 
-                if (usedDepthBuffers >= 3)
-                {
-                    GlStateManager.activeTexture(33996);
-                    GlStateManager.bindTexture(dfbDepthTextures.get(2));
-                }
-            }
+    public static void renderShadowComposites()
+    {
+        renderComposites(sfb, ProgramsShadowcomp, false, customTexturesShadowcomp);
+    }
 
-            for (int k = 0; k < usedShadowColorBuffers; ++k)
-            {
-                GlStateManager.activeTexture(33997 + k);
-                GlStateManager.bindTexture(sfbColorTextures.get(k));
-            }
+    private static void renderComposites(ShadersFramebuffer framebuffer, Program[] ps, boolean renderFinal, ICustomTexture[] customTextures)
+    {
+        GL43.glPushMatrix();
+        GL43.glLoadIdentity();
+        GL43.glMatrixMode(5889);
+        GL43.glPushMatrix();
+        GL43.glLoadIdentity();
+        GL43.glOrtho(0.0D, 1.0D, 0.0D, 1.0D, 0.0D, 1.0D);
+        GL43.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        GlStateManager.enableTexture();
+        GlStateManager.disableAlphaTest();
+        GlStateManager.disableBlend();
+        GlStateManager.enableDepthTest();
+        GlStateManager.depthFunc(519);
+        GlStateManager.depthMask(false);
+        GlStateManager.disableLighting();
+        bindTextures(0, customTextures);
+        framebuffer.bindColorImages(true);
+        framebuffer.setColorTextures(false);
+        framebuffer.setDepthTexture();
+        framebuffer.setDrawBuffers();
+        checkGLError("pre-composite");
 
-            if (noiseTextureEnabled)
-            {
-                GlStateManager.activeTexture(33984 + noiseTexture.getTextureUnit());
-                GlStateManager.bindTexture(noiseTexture.getTextureId());
-            }
+        for (int i = 0; i < ps.length; ++i)
+        {
+            Program program = ps[i];
+            dispatchComputes(framebuffer, program.getComputePrograms());
 
-            if (renderFinal)
-            {
-                bindCustomTextures(customTexturesComposite);
-            }
-            else
+            if (program.getId() != 0)
             {
-                bindCustomTextures(customTexturesDeferred);
-            }
+                useProgram(program);
+                checkGLError(program.getName());
 
-            GlStateManager.activeTexture(33984);
+                if (program.hasCompositeMipmaps())
+                {
+                    framebuffer.genCompositeMipmap(program.getCompositeMipmapSetting());
+                }
 
-            for (int l = 0; l < usedColorBuffers; ++l)
-            {
-                EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064 + l, 3553, dfbColorTexturesFlip.getB(l), 0);
+                preDrawComposite(framebuffer, program);
+                drawComposite();
+                postDrawComposite(framebuffer, program);
+                framebuffer.flipColorTextures(program.getToggleColorTextures());
             }
+        }
 
-            EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36096, 3553, dfbDepthTextures.get(0), 0);
-            GL32.glDrawBuffers(dfbDrawBuffers);
-            checkGLError("pre-composite");
-
-            for (int i1 = 0; i1 < ps.length; ++i1)
-            {
-                Program program = ps[i1];
-
-                if (program.getId() != 0)
-                {
-                    useProgram(program);
-                    checkGLError(program.getName());
-
-                    if (activeCompositeMipmapSetting != 0)
-                    {
-                        genCompositeMipmap();
-                    }
+        checkGLError("composite");
 
-                    preDrawComposite();
-                    drawComposite();
-                    postDrawComposite();
+        if (renderFinal)
+        {
+            renderFinal();
+            isCompositeRendered = true;
+        }
 
-                    for (int j = 0; j < usedColorBuffers; ++j)
-                    {
-                        if (program.getToggleColorTextures()[j])
-                        {
-                            dfbColorTexturesFlip.flip(j);
-                            GlStateManager.activeTexture(33984 + colorTextureImageUnit[j]);
-                            GlStateManager.bindTexture(dfbColorTexturesFlip.getA(j));
-                            EXTFramebufferObject.glFramebufferTexture2DEXT(36160, 36064 + j, 3553, dfbColorTexturesFlip.getB(j), 0);
-                        }
-                    }
+        GlStateManager.enableTexture();
+        GlStateManager.enableAlphaTest();
+        GlStateManager.enableBlend();
+        GlStateManager.depthFunc(515);
+        GlStateManager.depthMask(true);
+        GL43.glPopMatrix();
+        GL43.glMatrixMode(5888);
+        GL43.glPopMatrix();
+        useProgram(ProgramNone);
+    }
 
-                    GlStateManager.activeTexture(33984);
-                }
-            }
+    private static void preDrawComposite(ShadersFramebuffer framebuffer, Program program)
+    {
+        int i = framebuffer.getWidth();
+        int j = framebuffer.getHeight();
 
-            checkGLError("composite");
+        if (program.getDrawSize() != null)
+        {
+            Dimension dimension = program.getDrawSize().getDimension(i, j);
+            i = dimension.width;
+            j = dimension.height;
+            FixedFramebuffer fixedframebuffer = framebuffer.getFixedFramebuffer(i, j, program.getDrawBuffers(), false);
+            fixedframebuffer.bindFramebuffer();
+            GL43.glViewport(0, 0, i, j);
+        }
 
-            if (renderFinal)
-            {
-                renderFinal();
-                isCompositeRendered = true;
-            }
+        RenderScale renderscale = program.getRenderScale();
 
-            GlStateManager.enableLighting();
-            GlStateManager.enableTexture();
-            GlStateManager.enableAlphaTest();
-            GlStateManager.enableBlend();
-            GlStateManager.depthFunc(515);
-            GlStateManager.depthMask(true);
-            GL32.glPopMatrix();
-            GL32.glMatrixMode(5888);
-            GL32.glPopMatrix();
-            useProgram(ProgramNone);
+        if (renderscale != null)
+        {
+            int j1 = (int)((float)i * renderscale.getOffsetX());
+            int k = (int)((float)j * renderscale.getOffsetY());
+            int l = (int)((float)i * renderscale.getScale());
+            int i1 = (int)((float)j * renderscale.getScale());
+            GL43.glViewport(j1, k, l, i1);
         }
     }
 
-    private static void preDrawComposite()
+    private static void postDrawComposite(ShadersFramebuffer framebuffer, Program program)
     {
+        if (program.getDrawSize() != null)
+        {
+            framebuffer.bindFramebuffer();
+            GL43.glViewport(0, 0, framebuffer.getWidth(), framebuffer.getHeight());
+        }
+
         RenderScale renderscale = activeProgram.getRenderScale();
 
         if (renderscale != null)
         {
-            int i = (int)((float)renderWidth * renderscale.getOffsetX());
-            int j = (int)((float)renderHeight * renderscale.getOffsetY());
-            int k = (int)((float)renderWidth * renderscale.getScale());
-            int l = (int)((float)renderHeight * renderscale.getScale());
-            GL32.glViewport(i, j, k, l);
+            GL43.glViewport(0, 0, framebuffer.getWidth(), framebuffer.getHeight());
         }
     }
 
-    private static void postDrawComposite()
+    public static void dispatchComputes(ShadersFramebuffer framebuffer, ComputeProgram[] cps)
     {
-        RenderScale renderscale = activeProgram.getRenderScale();
+        for (int i = 0; i < cps.length; ++i)
+        {
+            ComputeProgram computeprogram = cps[i];
+            dispatchCompute(computeprogram);
 
-        if (renderscale != null)
+            if (computeprogram.hasCompositeMipmaps())
+            {
+                framebuffer.genCompositeMipmap(computeprogram.getCompositeMipmapSetting());
+            }
+        }
+    }
+
+    public static void dispatchCompute(ComputeProgram cp)
+    {
+        if (dfb != null)
         {
-            GL32.glViewport(0, 0, renderWidth, renderHeight);
+            ARBShaderObjects.glUseProgramObjectARB(cp.getId());
+
+            if (checkGLError("useComputeProgram") != 0)
+            {
+                cp.setId(0);
+            }
+            else
+            {
+                shaderUniforms.setProgram(cp.getId());
+
+                if (customUniforms != null)
+                {
+                    customUniforms.setProgram(cp.getId());
+                }
+
+                setProgramUniforms(cp.getProgramStage());
+                setImageUniforms();
+                dfb.bindColorImages(true);
+                Vector3i vector3i = cp.getWorkGroups();
+
+                if (vector3i == null)
+                {
+                    Vector2f vector2f = cp.getWorkGroupsRender();
+
+                    if (vector2f == null)
+                    {
+                        vector2f = new Vector2f(1.0F, 1.0F);
+                    }
+
+                    int i = (int)Math.ceil((double)((float)renderWidth * vector2f.x));
+                    int j = (int)Math.ceil((double)((float)renderHeight * vector2f.y));
+                    Vector3i vector3i1 = cp.getLocalSize();
+                    int k = (int)Math.ceil(1.0D * (double)i / (double)vector3i1.getX());
+                    int l = (int)Math.ceil(1.0D * (double)j / (double)vector3i1.getY());
+                    vector3i = new Vector3i(k, l, 1);
+                }
+
+                GL43.glMemoryBarrier(40);
+                GL43.glDispatchCompute(vector3i.getX(), vector3i.getY(), vector3i.getZ());
+                GL43.glMemoryBarrier(40);
+                checkGLError("compute");
+            }
         }
     }
 
     private static void renderFinal()
     {
+        dispatchComputes(dfb, ProgramFinal.getComputePrograms());
         isRenderingDfb = false;
         mc.getFramebuffer().bindFramebuffer(true);
         GlStateManager.framebufferTexture2D(FramebufferConstants.GL_FRAMEBUFFER, FramebufferConstants.GL_COLOR_ATTACHMENT0, 3553, mc.getFramebuffer().func_242996_f(), 0);
-        GL32.glViewport(0, 0, mc.getMainWindow().getFramebufferWidth(), mc.getMainWindow().getFramebufferHeight());
+        GL43.glViewport(0, 0, mc.getMainWindow().getFramebufferWidth(), mc.getMainWindow().getFramebufferHeight());
         GlStateManager.depthMask(true);
-        GL32.glClearColor(clearColorR, clearColorG, clearColorB, 1.0F);
-        GL32.glClear(16640);
-        GL32.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+        GL43.glClearColor(clearColor.getX(), clearColor.getY(), clearColor.getZ(), 1.0F);
+        GL43.glClear(16640);
+        GL43.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
         GlStateManager.enableTexture();
         GlStateManager.disableAlphaTest();
         GlStateManager.disableBlend();
@@ -4988,9 +5559,9 @@
         useProgram(ProgramFinal);
         checkGLError("final");
 
-        if (activeCompositeMipmapSetting != 0)
+        if (ProgramFinal.hasCompositeMipmaps())
         {
-            genCompositeMipmap();
+            dfb.genCompositeMipmap(ProgramFinal.getCompositeMipmapSetting());
         }
 
         drawComposite();
@@ -5013,6 +5584,7 @@
             isRenderingWorld = false;
             GlStateManager.colorMask(true, true, true, true);
             useProgram(ProgramNone);
+            setRenderStage(RenderStage.NONE);
             RenderHelper.disableStandardItemLighting();
             checkGLError("endRender end");
         }
@@ -5022,9 +5594,9 @@
     {
         isRenderingSky = true;
         fogEnabled = true;
-        setDrawBuffers(dfbDrawBuffers);
         useProgram(ProgramSkyTextured);
         pushEntity(-2, 0);
+        setRenderStage(RenderStage.SKY);
     }
 
     public static void setSkyColor(Vector3d v3color)
@@ -5105,9 +5677,9 @@
     public static void endSky()
     {
         isRenderingSky = false;
-        setDrawBuffers(dfbDrawBuffers);
         useProgram(lightmapEnabled ? ProgramTexturedLit : ProgramTextured);
         popEntity();
+        setRenderStage(RenderStage.NONE);
     }
 
     public static void beginUpdateChunks()
@@ -5156,6 +5728,7 @@
         fogEnabled = true;
         pushEntity(-3, 0);
         useProgram(ProgramClouds);
+        setRenderStage(RenderStage.CLOUDS);
     }
 
     public static void endClouds()
@@ -5163,6 +5736,7 @@
         disableFog();
         popEntity();
         useProgram(lightmapEnabled ? ProgramTexturedLit : ProgramTextured);
+        setRenderStage(RenderStage.NONE);
     }
 
     public static void beginEntities()
@@ -5170,6 +5744,7 @@
         if (isRenderingWorld)
         {
             useProgram(ProgramEntities);
+            setRenderStage(RenderStage.ENTITIES);
         }
     }
 
@@ -5261,7 +5836,7 @@
 
             if (!isShadowPass)
             {
-                setDrawBuffers(drawBuffersColorAtt0);
+                GlState.setDrawBuffers(drawBuffersColorAtt[0]);
             }
         }
     }
@@ -5270,7 +5845,7 @@
     {
         if (isRenderingWorld && !isShadowPass)
         {
-            setDrawBuffers(ProgramEntities.getDrawBuffers());
+            GlState.setDrawBuffers(ProgramEntities.getDrawBuffers());
         }
     }
 
@@ -5280,6 +5855,7 @@
         {
             checkGLError("beginBlockEntities");
             useProgram(ProgramBlock);
+            setRenderStage(RenderStage.BLOCK_ENTITIES);
         }
     }
 
@@ -5334,11 +5910,13 @@
     public static void beginParticles()
     {
         useProgram(ProgramTextured);
+        setRenderStage(RenderStage.PARTICLES);
     }
 
     public static void endParticles()
     {
         useProgram(ProgramTexturedLit);
+        setRenderStage(RenderStage.NONE);
     }
 
     public static void readCenterDepth()
@@ -5346,7 +5924,7 @@
         if (!isShadowPass && centerDepthSmoothEnabled)
         {
             ((Buffer)tempDirectFloatBuffer).clear();
-            GL32.glReadPixels(renderWidth / 2, renderHeight / 2, 1, 1, 6402, 5126, tempDirectFloatBuffer);
+            GL43.glReadPixels(renderWidth / 2, renderHeight / 2, 1, 1, 6402, 5126, tempDirectFloatBuffer);
             centerDepth = tempDirectFloatBuffer.get(0);
             float f = (float)diffSystemTime * 0.01F;
             float f1 = (float)Math.exp(Math.log(0.5D) * (double)f / (double)centerDepthSmoothHalflife);
@@ -5363,6 +5941,7 @@
             GlStateManager.blendFunc(770, 771);
             GlStateManager.enableAlphaTest();
             useProgram(ProgramWeather);
+            setRenderStage(RenderStage.RAIN_SNOW);
         }
     }
 
@@ -5370,6 +5949,7 @@
     {
         GlStateManager.disableBlend();
         useProgram(ProgramTexturedLit);
+        setRenderStage(RenderStage.NONE);
     }
 
     public static void preRenderHand()
@@ -5377,7 +5957,7 @@
         if (!isShadowPass && usedDepthBuffers >= 3)
         {
             GlStateManager.activeTexture(33996);
-            GL32.glCopyTexSubImage2D(3553, 0, 0, 0, 0, 0, renderWidth, renderHeight);
+            GL43.glCopyTexSubImage2D(3553, 0, 0, 0, 0, 0, renderWidth, renderHeight);
             GlStateManager.activeTexture(33984);
         }
     }
@@ -5388,7 +5968,7 @@
         {
             GlStateManager.activeTexture(33995);
             checkGLError("pre copy depth");
-            GL32.glCopyTexSubImage2D(3553, 0, 0, 0, 0, 0, renderWidth, renderHeight);
+            GL43.glCopyTexSubImage2D(3553, 0, 0, 0, 0, 0, renderWidth, renderHeight);
             checkGLError("copy depth");
             GlStateManager.activeTexture(33984);
         }
@@ -5436,11 +6016,11 @@
 
     public static void beginHand(MatrixStack matrixStackIn, boolean translucent)
     {
-        GL32.glMatrixMode(5888);
-        GL32.glPushMatrix();
-        GL32.glMatrixMode(5889);
-        GL32.glPushMatrix();
-        GL32.glMatrixMode(5888);
+        GL43.glMatrixMode(5888);
+        GL43.glPushMatrix();
+        GL43.glMatrixMode(5889);
+        GL43.glPushMatrix();
+        GL43.glMatrixMode(5888);
         matrixStackIn.push();
 
         if (translucent)
@@ -5461,10 +6041,10 @@
         checkGLError("pre endHand");
         checkFramebufferStatus("pre endHand");
         matrixStackIn.pop();
-        GL32.glMatrixMode(5889);
-        GL32.glPopMatrix();
-        GL32.glMatrixMode(5888);
-        GL32.glPopMatrix();
+        GL43.glMatrixMode(5889);
+        GL43.glPopMatrix();
+        GL43.glMatrixMode(5888);
+        GL43.glPopMatrix();
         GlStateManager.blendFunc(770, 771);
         checkGLError("endHand");
     }
@@ -5481,7 +6061,7 @@
 
     public static void glEnableWrapper(int cap)
     {
-        GL32.glEnable(cap);
+        GL43.glEnable(cap);
 
         if (cap == 3553)
         {
@@ -5495,7 +6075,7 @@
 
     public static void glDisableWrapper(int cap)
     {
-        GL32.glDisable(cap);
+        GL43.glDisable(cap);
 
         if (cap == 3553)
         {
@@ -5509,25 +6089,25 @@
 
     public static void sglEnableT2D(int cap)
     {
-        GL32.glEnable(cap);
+        GL43.glEnable(cap);
         enableTexture2D();
     }
 
     public static void sglDisableT2D(int cap)
     {
-        GL32.glDisable(cap);
+        GL43.glDisable(cap);
         disableTexture2D();
     }
 
     public static void sglEnableFog(int cap)
     {
-        GL32.glEnable(cap);
+        GL43.glEnable(cap);
         enableFog();
     }
 
     public static void sglDisableFog(int cap)
     {
-        GL32.glDisable(cap);
+        GL43.glDisable(cap);
         disableFog();
     }
 
@@ -5755,6 +6335,11 @@
     public static void resourcesReloaded()
     {
         loadShaderPackResources();
+        reloadCustomTexturesLocation(customTexturesGbuffers);
+        reloadCustomTexturesLocation(customTexturesComposite);
+        reloadCustomTexturesLocation(customTexturesDeferred);
+        reloadCustomTexturesLocation(customTexturesShadowcomp);
+        reloadCustomTexturesLocation(customTexturesPrepare);
 
         if (shaderPackLoaded)
         {
@@ -5767,7 +6352,7 @@
     private static void loadShaderPackResources()
     {
         shaderPackResources = new HashMap<>();
-
+        System.out.println("loadShaderPackResources " + shaderPackLoaded);
         if (shaderPackLoaded)
         {
             List<String> list = new ArrayList<>();
@@ -5800,6 +6385,7 @@
                         {
                             String s6 = properties.getProperty(s5);
                             shaderPackResources.put(s5, s6);
+                            System.out.println("put " + s5 + " " + s6);
                         }
                     }
                 }
@@ -5957,9 +6543,24 @@
         return shadowDistanceRenderMul < 0.0F ? -1.0F : shadowMapHalfPlane * shadowDistanceRenderMul;
     }
 
-    public static void setRenderingFirstPersonHand(boolean flag)
+    public static void beginRenderFirstPersonHand(boolean translucent)
     {
-        isRenderingFirstPersonHand = flag;
+        isRenderingFirstPersonHand = true;
+
+        if (translucent)
+        {
+            setRenderStage(RenderStage.HAND_TRANSLUCENT);
+        }
+        else
+        {
+            setRenderStage(RenderStage.HAND_SOLID);
+        }
+    }
+
+    public static void endRenderFirstPersonHand()
+    {
+        isRenderingFirstPersonHand = false;
+        setRenderStage(RenderStage.NONE);
     }
 
     public static boolean isRenderingFirstPersonHand()
@@ -6022,4 +6623,13 @@
     {
         RenderUtils.flushRenderBuffers();
     }
+
+    public static void setRenderStage(RenderStage stage)
+    {
+        if (shaderPackLoaded)
+        {
+            renderStage = stage;
+            uniform_renderStage.setValue(stage.ordinal());
+        }
+    }
 }
